%%
%% This is file `zref-clever.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% zref-clever.dtx  (with options: `package')
%% 
%% This file was generated from file(s) of the LaTeX package "zref-clever".
%% 
%% Copyright (C) 2021-2024  gusbrs
%% 
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file:
%% 
%%    https://www.latex-project.org/lppl.txt
%% 
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 2005/12/01 or later.
%% 
%% 
%% This work is "maintained" (as per LPPL maintenance status) by gusbrs.
%% 
%% This work consists of the files zref-clever.dtx,
%%                                 zref-clever.ins,
%%                                 zref-clever-doc.tex,
%%                                 zref-clever-code.tex,
%%                   and the files generated from them.
%% 
%% The released version of this package is available from CTAN.
%% 
%% -----------------------------------------------------------------------
%% 
%% The development version of the package can be found at
%% 
%%    https://github.com/gusbrs/zref-clever
%% 
%% for those people who are interested.
%% 
%% -----------------------------------------------------------------------
%% 
\def\zrefclever@required@kernel{2023-11-01}
\NeedsTeXFormat{LaTeX2e}[\zrefclever@required@kernel]
\providecommand\IfFormatAtLeastTF{\@ifl@t@r\fmtversion}
\IfFormatAtLeastTF{\zrefclever@required@kernel}
  {}
  {%
    \PackageError{zref-clever}{LaTeX kernel too old}
      {%
        'zref-clever' requires a LaTeX kernel \zrefclever@required@kernel\space or newer.%
      }%
  }%
\ProvidesExplPackage {zref-clever} {2024-11-28} {0.5.1}
  {Clever LaTeX cross-references based on zref}
\RequirePackage { zref-base }
\RequirePackage { zref-user }
\RequirePackage { zref-abspage }
\RequirePackage { ifdraft }
\zref@newprop { zc@counter } { \l__zrefclever_current_counter_tl }
\zref@addprop \ZREF@mainlist { zc@counter }
\zref@newprop { thecounter }
  {
    \cs_if_exist:cTF { c@ \l__zrefclever_current_counter_tl }
      { \use:c { the \l__zrefclever_current_counter_tl } }
      {
        \cs_if_exist:cT { c@ \@currentcounter }
          { \use:c { the \@currentcounter } }
      }
  }
\zref@addprop \ZREF@mainlist { thecounter }
\zref@newprop { zc@type }
  {
    \tl_if_empty:NTF \l__zrefclever_reftype_override_tl
      {
        \exp_args:NNe \prop_if_in:NnTF \l__zrefclever_counter_type_prop
          \l__zrefclever_current_counter_tl
          {
            \exp_args:NNe \prop_item:Nn \l__zrefclever_counter_type_prop
              { \l__zrefclever_current_counter_tl }
          }
          { \l__zrefclever_current_counter_tl }
      }
      { \l__zrefclever_reftype_override_tl }
  }
\zref@addprop \ZREF@mainlist { zc@type }
\zref@newprop { zc@cntval } [0]
  {
    \bool_lazy_and:nnTF
      { ! \tl_if_empty_p:N \l__zrefclever_current_counter_tl }
      { \cs_if_exist_p:c { c@ \l__zrefclever_current_counter_tl } }
      { \int_use:c { c@ \l__zrefclever_current_counter_tl } }
      {
        \bool_lazy_and:nnTF
          { ! \tl_if_empty_p:N \@currentcounter }
          { \cs_if_exist_p:c { c@ \@currentcounter } }
          { \int_use:c { c@ \@currentcounter } }
          { 0 }
      }
  }
\zref@addprop \ZREF@mainlist { zc@cntval }
\zref@newprop* { zc@pgval } [0] { \int_use:c { c@page } }
\zref@addprop \ZREF@mainlist { zc@pgval }
\cs_new:Npn \__zrefclever_get_enclosing_counters:n #1
  {
    \cs_if_exist:cT { c@ \__zrefclever_counter_reset_by:n {#1} }
      {
        { \__zrefclever_counter_reset_by:n {#1} }
        \__zrefclever_get_enclosing_counters:e
          { \__zrefclever_counter_reset_by:n {#1} }
      }
  }
\cs_new:Npn \__zrefclever_get_enclosing_counters_value:n #1
  {
    \cs_if_exist:cT { c@ \__zrefclever_counter_reset_by:n {#1} }
      {
        { \int_use:c { c@ \__zrefclever_counter_reset_by:n {#1} } }
        \__zrefclever_get_enclosing_counters_value:e
          { \__zrefclever_counter_reset_by:n {#1} }
      }
  }
\cs_generate_variant:Nn \__zrefclever_get_enclosing_counters:n { e }
\cs_generate_variant:Nn \__zrefclever_get_enclosing_counters_value:n { e }
\cs_new:Npn \__zrefclever_counter_reset_by:n #1
  {
    \bool_if:nTF
      { \prop_if_in_p:Nn \l__zrefclever_counter_resetby_prop {#1} }
      { \prop_item:Nn \l__zrefclever_counter_resetby_prop {#1} }
      {
        \seq_map_tokens:Nn \l__zrefclever_counter_resetters_seq
          { \__zrefclever_counter_reset_by_aux:nn {#1} }
      }
  }
\cs_new:Npn \__zrefclever_counter_reset_by_aux:nn #1#2
  {
    \cs_if_exist:cT { c@ #2 }
      {
        \tl_if_empty:cF { cl@ #2 }
          {
            \tl_map_tokens:cn { cl@ #2 }
              { \__zrefclever_counter_reset_by_auxi:nnn {#2} {#1} }
          }
      }
  }
\cs_new:Npn \__zrefclever_counter_reset_by_auxi:nnn #1#2#3
  {
    \str_if_eq:nnT {#2} {#3}
      { \tl_map_break:n { \seq_map_break:n {#1} } }
  }
\zref@newprop { zc@enclval }
  {
    \__zrefclever_get_enclosing_counters_value:e
      { \l__zrefclever_current_counter_tl }
  }
\zref@addprop \ZREF@mainlist { zc@enclval }
\zref@newprop { zc@enclcnt }
  { \__zrefclever_get_enclosing_counters:e \l__zrefclever_current_counter_tl }
\int_new:N \g__zrefclever_page_format_int
\tl_new:N \g__zrefclever_prev_page_format_tl
\AddToHook { shipout / before }
  {
    \tl_if_eq:NNF \g__zrefclever_prev_page_format_tl \thepage
      {
        \int_gincr:N \g__zrefclever_page_format_int
        \tl_gset_eq:NN \g__zrefclever_prev_page_format_tl \thepage
      }
  }
\zref@newprop* { zc@pgfmt } { \int_use:N \g__zrefclever_page_format_int }
\zref@addprop \ZREF@mainlist { zc@pgfmt }
\prg_new_conditional:Npnn \__zrefclever_if_package_loaded:n #1 { T , F , TF }
  { \IfPackageLoadedTF {#1} { \prg_return_true: } { \prg_return_false: } }
\prg_new_conditional:Npnn \__zrefclever_if_class_loaded:n #1 { T , F , TF }
  { \IfClassLoadedTF {#1} { \prg_return_true: } { \prg_return_false: } }
\tl_new:N \l__zrefclever_tmpa_tl
\tl_new:N \l__zrefclever_tmpb_tl
\seq_new:N \l__zrefclever_tmpa_seq
\seq_new:N \g__zrefclever_tmpa_seq
\bool_new:N \l__zrefclever_tmpa_bool
\int_new:N \l__zrefclever_tmpa_int
\msg_new:nnn { zref-clever } { option-not-type-specific }
  {
    Option~'#1'~is~not~type-specific~\msg_line_context:.~
    Set~it~in~'\iow_char:N\\zcLanguageSetup'~before~first~'type'~
    switch~or~as~package~option.
  }
\msg_new:nnn { zref-clever } { option-only-type-specific }
  {
    No~type~specified~for~option~'#1'~\msg_line_context:.~
    Set~it~after~'type'~switch.
  }
\msg_new:nnn { zref-clever } { key-requires-value }
  { The~'#1'~key~'#2'~requires~a~value~\msg_line_context:. }
\msg_new:nnn { zref-clever } { language-declared }
  { Language~'#1'~is~already~declared~\msg_line_context:.~Nothing~to~do. }
\msg_new:nnn { zref-clever } { unknown-language-alias }
  {
    Language~'#1'~is~unknown~\msg_line_context:.~Can't~alias~to~it.~
    See~documentation~for~'\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { unknown-language-setup }
  {
    Language~'#1'~is~unknown~\msg_line_context:.~Can't~set~it~up.~
    See~documentation~for~'\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { unknown-language-opt }
  {
    Language~'#1'~is~unknown~\msg_line_context:.~
    See~documentation~for~'\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { unknown-language-variant }
  {
    Can't~set~variant~'#1'~for~unknown~language~'#2'~\msg_line_context:.~
    See~documentation~for~'\iow_char:N\\zcDeclareLanguage'~and~
    '\iow_char:N\\zcDeclareLanguageAlias'.
  }
\msg_new:nnn { zref-clever } { language-no-variants-ref }
  {
    Language~'#1'~has~no~declared~variants~\msg_line_context:.~
    Nothing~to~do~with~option~'v=#2'.
  }
\msg_new:nnn { zref-clever } { language-no-gender }
  {
    Language~'#1'~has~no~declared~gender~\msg_line_context:.~
    Nothing~to~do~with~option~'#2=#3'.
  }
\msg_new:nnn { zref-clever } { language-no-variants-setup }
  {
    Language~'#1'~has~no~declared~variants~\msg_line_context:.~
    Nothing~to~do~with~option~'variant=#2'.
  }
\msg_new:nnn { zref-clever } { unknown-variant }
  {
    Variant~'#1'~unknown~for~language~'#2'~\msg_line_context:.~
    Using~default~variant.
  }
\msg_new:nnn { zref-clever } { nudge-multitype }
  {
    Reference~with~multiple~types~\msg_line_context:.~
    You~may~wish~to~separate~them~or~review~language~around~it.
  }
\msg_new:nnn { zref-clever } { nudge-comptosing }
  {
    Multiple~labels~have~been~compressed~into~singular~type~name~
    for~type~'#1'~\msg_line_context:.
  }
\msg_new:nnn { zref-clever } { nudge-plural-when-sg }
  {
    Option~'sg'~signals~that~a~singular~type~name~was~expected~
    \msg_line_context:.~But~type~'#1'~has~plural~type~name.
  }
\msg_new:nnn { zref-clever } { gender-not-declared }
  { Language~'#1'~has~no~'#2'~gender~declared~\msg_line_context:. }
\msg_new:nnn { zref-clever } { nudge-gender-mismatch }
  {
    Gender~mismatch~for~type~'#1'~\msg_line_context:.~
    You've~specified~'g=#2'~but~type~name~is~'#3'~for~language~'#4'.
  }
\msg_new:nnn { zref-clever } { nudge-gender-not-declared-for-type }
  {
    You've~specified~'g=#1'~\msg_line_context:.~
    But~gender~for~type~'#2'~is~not~declared~for~language~'#3'.
  }
\msg_new:nnn { zref-clever } { nudgeif-unknown-value }
  { Unknown~value~'#1'~for~'nudgeif'~option~\msg_line_context:. }
\msg_new:nnn { zref-clever } { option-document-only }
  { Option~'#1'~is~only~available~after~\iow_char:N\\begin\{document\}. }
\msg_new:nnn { zref-clever } { langfile-loaded }
  { Loaded~'#1'~language~file. }
\msg_new:nnn { zref-clever } { zref-property-undefined }
  {
    Option~'ref=#1'~requested~\msg_line_context:.~
    But~the~property~'#1'~is~not~declared,~falling-back~to~'default'.
  }
\msg_new:nnn { zref-clever } { endrange-property-undefined }
  {
    Option~'endrange=#1'~requested~\msg_line_context:.~
    But~the~property~'#1'~is~not~declared,~'endrange'~not~set.
  }
\msg_new:nnn { zref-clever } { hyperref-preamble-only }
  {
    Option~'hyperref'~only~available~in~the~preamble~\msg_line_context:.~
    To~inhibit~hyperlinking~locally,~you~can~use~the~starred~version~of~
    '\iow_char:N\\zcref'.
  }
\msg_new:nnn { zref-clever } { missing-hyperref }
  { Missing~'hyperref'~package.~Setting~'hyperref=false'. }
\msg_new:nnn { zref-clever } { option-preamble-only }
  { Option~'#1'~only~available~in~the~preamble~\msg_line_context:. }
\msg_new:nnn { zref-clever } { unknown-compat-module }
  {
    Unknown~compatibility~module~'#1'~given~to~option~'nocompat'.~
    Nothing~to~do.
  }
\msg_new:nnn { zref-clever } { refbounds-must-be-four }
  {
    The~value~of~option~'#1'~must~be~a~comma~sepatared~list~
    of~four~items.~We~received~'#2'~items~\msg_line_context:.~
    Option~not~set.
  }
\msg_new:nnn { zref-clever } { missing-zref-check }
  {
    Option~'check'~requested~\msg_line_context:.~
    But~package~'zref-check'~is~not~loaded,~can't~run~the~checks.
  }
\msg_new:nnn { zref-clever } { zref-check-too-old }
  {
    Option~'check'~requested~\msg_line_context:.~
    But~'zref-check'~newer~than~'#1'~is~required,~can't~run~the~checks.
  }
\msg_new:nnn { zref-clever } { missing-type }
  { Reference~type~undefined~for~label~'#1'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-property }
  { Reference~property~'#1'~undefined~for~label~'#2'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { missing-name }
  { Reference~format~option~'#1'~undefined~for~type~'#2'~\msg_line_context:. }
\msg_new:nnn { zref-clever } { single-element-range }
  { Range~for~type~'#1'~resulted~in~single~element~\msg_line_context:. }
\msg_new:nnn { zref-clever } { compat-package }
  { Loaded~support~for~'#1'~package. }
\msg_new:nnn { zref-clever } { compat-class }
  { Loaded~support~for~'#1'~documentclass. }
\msg_new:nnn { zref-clever } { option-deprecated }
  {
    Option~'#1'~has~been~deprecated~\msg_line_context:.\iow_newline:
    Use~'#2'~instead.
  }
\msg_new:nnn { zref-clever } { load-time-options }
  {
    'zref-clever'~does~not~accept~load-time~options.~
    To~configure~package~options,~use~'\iow_char:N\\zcsetup'.
  }
\cs_new_protected:Npn \__zrefclever_extract_default:Nnnn #1#2#3#4
  {
    \exp_args:NNNo \exp_args:NNo \tl_set:Nn #1
      { \zref@extractdefault {#2} {#3} {#4} }
  }
\cs_generate_variant:Nn \__zrefclever_extract_default:Nnnn { NVnn , Nnvn }
\cs_new:Npn \__zrefclever_extract_unexp:nnn #1#2#3
  {
    \exp_args:NNo \exp_args:No
      \exp_not:n { \zref@extractdefault {#1} {#2} {#3} }
  }
\cs_generate_variant:Nn \__zrefclever_extract_unexp:nnn { Vnn , nvn , Vvn }
\cs_new:Npn \__zrefclever_extract:nnn #1#2#3
  { \zref@extractdefault {#1} {#2} {#3} }
\cs_new:Npn \__zrefclever_opt_varname_general:nn #1#2
  { l__zrefclever_opt_general_ #1 _ #2 }
\cs_new:Npn \__zrefclever_opt_varname_type:nnn #1#2#3
  { l__zrefclever_opt_type_ #1 _ #2 _ #3 }
\cs_generate_variant:Nn \__zrefclever_opt_varname_type:nnn { enn , een }
\cs_new:Npn \__zrefclever_opt_varname_language:nnn #1#2#3
  {
    \__zrefclever_language_if_declared:nTF {#1}
      {
        g__zrefclever_opt_language_
        \tl_use:c { \__zrefclever_language_varname:n {#1} }
        _ #2 _ #3
      }
      { g__zrefclever_opt_lang_unknown_ \int_rand:n { 1000000 } _ #3 }
  }
\cs_generate_variant:Nn \__zrefclever_opt_varname_language:nnn { enn }
\cs_new:Npn \__zrefclever_opt_varname_lang_default:nnn #1#2#3
  {
    \__zrefclever_language_if_declared:nTF {#1}
      {
        g__zrefclever_opt_lang_
        \tl_use:c { \__zrefclever_language_varname:n {#1} }
        _default_ #2 _ #3
      }
      { g__zrefclever_opt_lang_unknown_ \int_rand:n { 1000000 } _ #3 }
  }
\cs_generate_variant:Nn \__zrefclever_opt_varname_lang_default:nnn { enn }
\cs_new:Npn \__zrefclever_opt_varname_lang_type:nnnn #1#2#3#4
  {
    \__zrefclever_language_if_declared:nTF {#1}
      {
        g__zrefclever_opt_lang_
        \tl_use:c { \__zrefclever_language_varname:n {#1} }
        _type_ #2 _ #3 _ #4
      }
      { g__zrefclever_opt_lang_unknown_ \int_rand:n { 1000000 } _ #4 }
  }
\cs_generate_variant:Nn
  \__zrefclever_opt_varname_lang_type:nnnn { eenn , eeen }
\cs_new:Npn \__zrefclever_opt_varname_fallback:nn #1#2
  { c__zrefclever_opt_fallback_ #1 _ #2 }
\cs_new:Npn \__zrefclever_opt_var_set_bool:n #1
  { \cs_to_str:N #1 _is_set_bool }
\cs_new_protected:Npn \__zrefclever_opt_tl_set:Nn #1#2
  {
    \tl_if_exist:NF #1
      { \tl_new:N #1 }
    \tl_set:Nn #1 {#2}
    \bool_if_exist:cF { \__zrefclever_opt_var_set_bool:n {#1} }
      { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
    \bool_set_true:c { \__zrefclever_opt_var_set_bool:n {#1} }
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_set:Nn { cn }
\cs_new_protected:Npn \__zrefclever_opt_tl_clear:N #1
  {
    \tl_if_exist:NF #1
      { \tl_new:N #1 }
    \tl_clear:N #1
    \bool_if_exist:cF { \__zrefclever_opt_var_set_bool:n {#1} }
      { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
    \bool_set_true:c { \__zrefclever_opt_var_set_bool:n {#1} }
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_clear:N { c }
\cs_new_protected:Npn \__zrefclever_opt_tl_gset:Nn #1#2
  {
    \tl_if_exist:NF #1
      { \tl_new:N #1 }
    \tl_gset:Nn #1 {#2}
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_gset:Nn { cn }
\cs_new_protected:Npn \__zrefclever_opt_tl_gclear:N #1
  {
    \tl_if_exist:NF #1
      { \tl_new:N #1 }
    \tl_gclear:N #1
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_gclear:N { c }
\cs_new_protected:Npn \__zrefclever_opt_tl_unset:N #1
  {
    \tl_if_exist:NT #1
      {
        \tl_clear:N #1
        \bool_if_exist:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
          { \bool_set_false:c { \__zrefclever_opt_var_set_bool:n {#1} } }
          { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
      }
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_unset:N { c }
\prg_new_conditional:Npnn \__zrefclever_opt_tl_if_set:N #1 { F , TF }
  {
    \tl_if_exist:NTF #1
      {
        \bool_if_exist:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
          {
            \bool_if:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
              { \prg_return_true:  }
              { \prg_return_false: }
          }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }
\cs_new_protected:Npn \__zrefclever_opt_tl_gset_if_new:Nn #1#2
  {
    \__zrefclever_opt_tl_if_set:NF #1
      {
        \tl_if_exist:NF #1
          { \tl_new:N #1 }
        \tl_gset:Nn #1 {#2}
      }
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_gset_if_new:Nn { cn }
\cs_new_protected:Npn \__zrefclever_opt_tl_gclear_if_new:N #1
  {
    \__zrefclever_opt_tl_if_set:NF #1
      {
        \tl_if_exist:NF #1
          { \tl_new:N #1 }
        \tl_gclear:N #1
      }
  }
\cs_generate_variant:Nn \__zrefclever_opt_tl_gclear_if_new:N { c }
\prg_new_protected_conditional:Npnn \__zrefclever_opt_tl_get:NN #1#2 { F }
  {
    \__zrefclever_opt_tl_if_set:NTF #1
      {
        \tl_set_eq:NN #2 #1
        \prg_return_true:
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_opt_tl_get:NN { cN } { F }
\cs_new_protected:Npn \__zrefclever_opt_seq_set_clist_split:Nn #1#2
  { \seq_set_split:Nnn #1 { , } {#2} }
\cs_new_protected:Npn \__zrefclever_opt_seq_gset_clist_split:Nn #1#2
  { \seq_gset_split:Nnn #1 { , } {#2} }
\cs_new_protected:Npn \__zrefclever_opt_seq_set_eq:NN #1#2
  {
    \seq_if_exist:NF #1
      { \seq_new:N #1 }
    \seq_set_eq:NN #1 #2
    \bool_if_exist:cF { \__zrefclever_opt_var_set_bool:n {#1} }
      { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
    \bool_set_true:c { \__zrefclever_opt_var_set_bool:n {#1} }
  }
\cs_generate_variant:Nn \__zrefclever_opt_seq_set_eq:NN { cN }
\cs_new_protected:Npn \__zrefclever_opt_seq_gset_eq:NN #1#2
  {
    \seq_if_exist:NF #1
      { \seq_new:N #1 }
    \seq_gset_eq:NN #1 #2
  }
\cs_generate_variant:Nn \__zrefclever_opt_seq_gset_eq:NN { cN }
\cs_new_protected:Npn \__zrefclever_opt_seq_unset:N #1
  {
    \seq_if_exist:NT #1
      {
        \seq_clear:N #1
        \bool_if_exist:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
          { \bool_set_false:c { \__zrefclever_opt_var_set_bool:n {#1} } }
          { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
      }
  }
\cs_generate_variant:Nn \__zrefclever_opt_seq_unset:N { c }
\prg_new_conditional:Npnn \__zrefclever_opt_seq_if_set:N #1 { F , TF }
  {
    \seq_if_exist:NTF #1
      {
        \bool_if_exist:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
          {
            \bool_if:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
              { \prg_return_true:  }
              { \prg_return_false: }
          }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_opt_seq_if_set:N { c } { F , TF }
\prg_new_protected_conditional:Npnn \__zrefclever_opt_seq_get:NN #1#2 { F }
  {
    \__zrefclever_opt_seq_if_set:NTF #1
      {
        \seq_set_eq:NN #2 #1
        \prg_return_true:
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_opt_seq_get:NN { cN } { F }
\cs_new_protected:Npn \__zrefclever_opt_bool_unset:N #1
  {
    \bool_if_exist:NT #1
      {
        % \bool_set_false:N #1
        \bool_if_exist:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
          { \bool_set_false:c { \__zrefclever_opt_var_set_bool:n {#1} } }
          { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
      }
  }
\cs_generate_variant:Nn \__zrefclever_opt_bool_unset:N { c }
\prg_new_conditional:Npnn \__zrefclever_opt_bool_if_set:N #1 { F , TF }
  {
    \bool_if_exist:NTF #1
      {
        \bool_if_exist:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
          {
            \bool_if:cTF { \__zrefclever_opt_var_set_bool:n {#1} }
              { \prg_return_true:  }
              { \prg_return_false: }
          }
          { \prg_return_true: }
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_opt_bool_if_set:N { c } { F , TF }
\cs_new_protected:Npn \__zrefclever_opt_bool_set_true:N #1
  {
    \bool_if_exist:NF #1
      { \bool_new:N #1 }
    \bool_set_true:N #1
    \bool_if_exist:cF { \__zrefclever_opt_var_set_bool:n {#1} }
      { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
    \bool_set_true:c { \__zrefclever_opt_var_set_bool:n {#1} }
  }
\cs_generate_variant:Nn \__zrefclever_opt_bool_set_true:N { c }
\cs_new_protected:Npn \__zrefclever_opt_bool_set_false:N #1
  {
    \bool_if_exist:NF #1
      { \bool_new:N #1 }
    \bool_set_false:N #1
    \bool_if_exist:cF { \__zrefclever_opt_var_set_bool:n {#1} }
      { \bool_new:c { \__zrefclever_opt_var_set_bool:n {#1} } }
    \bool_set_true:c { \__zrefclever_opt_var_set_bool:n {#1} }
  }
\cs_generate_variant:Nn \__zrefclever_opt_bool_set_false:N { c }
\cs_new_protected:Npn \__zrefclever_opt_bool_gset_true:N #1
  {
    \bool_if_exist:NF #1
      { \bool_new:N #1 }
    \bool_gset_true:N #1
  }
\cs_generate_variant:Nn \__zrefclever_opt_bool_gset_true:N { c }
\cs_new_protected:Npn \__zrefclever_opt_bool_gset_false:N #1
  {
    \bool_if_exist:NF #1
      { \bool_new:N #1 }
    \bool_gset_false:N #1
  }
\cs_generate_variant:Nn \__zrefclever_opt_bool_gset_false:N { c }
\prg_new_protected_conditional:Npnn \__zrefclever_opt_bool_get:NN #1#2 { F }
  {
    \__zrefclever_opt_bool_if_set:NTF #1
      {
        \bool_set_eq:NN #2 #1
        \prg_return_true:
      }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_opt_bool_get:NN { cN } { F }
\prg_new_conditional:Npnn \__zrefclever_opt_bool_if:N #1 { T , F , TF }
  {
    \__zrefclever_opt_bool_if_set:NTF #1
      { \bool_if:NTF #1 { \prg_return_true: } { \prg_return_false: } }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_opt_bool_if:N { c } { T , F , TF }
\tl_new:N \l__zrefclever_setup_type_tl
\tl_new:N \l__zrefclever_setup_language_tl
\tl_new:N \l__zrefclever_lang_variant_tl
\seq_new:N \l__zrefclever_lang_variants_seq
\seq_new:N \l__zrefclever_lang_gender_seq
\seq_new:N \g__zrefclever_rf_opts_tl_not_type_specific_seq
\seq_gset_from_clist:Nn
  \g__zrefclever_rf_opts_tl_not_type_specific_seq
  {
    tpairsep ,
    tlistsep ,
    tlastsep ,
    notesep ,
  }
\seq_new:N \g__zrefclever_rf_opts_tl_maybe_type_specific_seq
\seq_gset_from_clist:Nn
  \g__zrefclever_rf_opts_tl_maybe_type_specific_seq
  {
    namesep ,
    pairsep ,
    listsep ,
    lastsep ,
    rangesep ,
    namefont ,
    reffont ,
  }
\seq_new:N \g__zrefclever_rf_opts_seq_refbounds_seq
\seq_gset_from_clist:Nn
  \g__zrefclever_rf_opts_seq_refbounds_seq
  {
    refbounds-first ,
    refbounds-first-sg ,
    refbounds-first-pb ,
    refbounds-first-rb ,
    refbounds-mid ,
    refbounds-mid-rb ,
    refbounds-mid-re ,
    refbounds-last ,
    refbounds-last-pe ,
    refbounds-last-re ,
  }
\seq_new:N \g__zrefclever_rf_opts_bool_maybe_type_specific_seq
\seq_gset_from_clist:Nn
  \g__zrefclever_rf_opts_bool_maybe_type_specific_seq
  {
    cap ,
    abbrev ,
    rangetopair ,
  }
\seq_new:N \g__zrefclever_rf_opts_tl_type_names_seq
\seq_gset_from_clist:Nn
  \g__zrefclever_rf_opts_tl_type_names_seq
  {
    Name-sg ,
    name-sg ,
    Name-pl ,
    name-pl ,
    Name-sg-ab ,
    name-sg-ab ,
    Name-pl-ab ,
    name-pl-ab ,
  }
\seq_new:N \g__zrefclever_rf_opts_tl_typesetup_seq
\seq_gconcat:NNN \g__zrefclever_rf_opts_tl_typesetup_seq
  \g__zrefclever_rf_opts_tl_maybe_type_specific_seq
  \g__zrefclever_rf_opts_tl_type_names_seq
\seq_new:N \g__zrefclever_rf_opts_tl_reference_seq
\seq_gconcat:NNN \g__zrefclever_rf_opts_tl_reference_seq
  \g__zrefclever_rf_opts_tl_not_type_specific_seq
  \g__zrefclever_rf_opts_tl_maybe_type_specific_seq
\clist_map_inline:nn
  {
    reference ,
    typesetup ,
    langsetup ,
    langfile ,
  }
  {
    \keys_define:nn { zref-clever/ #1 }
      {
        +refbounds-first .meta:n =
          {
            refbounds-first = {##1} ,
            refbounds-first-sg = {##1} ,
            refbounds-first-pb = {##1} ,
            refbounds-first-rb = {##1} ,
          } ,
        +refbounds-mid .meta:n =
          {
            refbounds-mid = {##1} ,
            refbounds-mid-rb = {##1} ,
            refbounds-mid-re = {##1} ,
          } ,
        +refbounds-last .meta:n =
          {
            refbounds-last = {##1} ,
            refbounds-last-pe = {##1} ,
            refbounds-last-re = {##1} ,
          } ,
        +refbounds-rb .meta:n =
          {
            refbounds-first-rb = {##1} ,
            refbounds-mid-rb = {##1} ,
          } ,
        +refbounds-re .meta:n =
          {
            refbounds-mid-re = {##1} ,
            refbounds-last-re = {##1} ,
          } ,
        +refbounds .meta:n =
          {
            +refbounds-first = {##1} ,
            +refbounds-mid = {##1} ,
            +refbounds-last = {##1} ,
          } ,
        refbounds .meta:n = { +refbounds = {##1} } ,
      }
  }
\clist_map_inline:nn
  {
    reference ,
    typesetup ,
  }
  {
    \keys_define:nn { zref-clever/ #1 }
      {
        +refbounds-first .default:o = \c_novalue_tl ,
        +refbounds-mid .default:o = \c_novalue_tl ,
        +refbounds-last .default:o = \c_novalue_tl ,
        +refbounds-rb .default:o = \c_novalue_tl ,
        +refbounds-re .default:o = \c_novalue_tl ,
        +refbounds .default:o = \c_novalue_tl ,
        refbounds .default:o = \c_novalue_tl ,
      }
  }
\clist_map_inline:nn
  {
    langsetup ,
    langfile ,
  }
  {
    \keys_define:nn { zref-clever/ #1 }
      {
        +refbounds-first .value_required:n = true ,
        +refbounds-mid .value_required:n = true ,
        +refbounds-last .value_required:n = true ,
        +refbounds-rb .value_required:n = true ,
        +refbounds-re .value_required:n = true ,
        +refbounds .value_required:n = true ,
        refbounds .value_required:n = true ,
      }
  }
\tl_new:N \l__zrefclever_ref_language_tl
\tl_new:N \l__zrefclever_current_language_tl
\tl_new:N \l__zrefclever_main_language_tl
\tl_new:N \l_zrefclever_ref_language_tl
\tl_set:Nn \l_zrefclever_ref_language_tl { \l__zrefclever_ref_language_tl }
\cs_new:Npn \__zrefclever_language_varname:n #1
  { g__zrefclever_declared_language_ #1 _tl }
\cs_set_eq:NN \zrefclever_language_varname:n
  \__zrefclever_language_varname:n
\prg_new_conditional:Npnn \__zrefclever_language_if_declared:n #1 { T , F , TF }
  {
    \tl_if_exist:cTF { \__zrefclever_language_varname:n {#1} }
      { \prg_return_true:  }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_language_if_declared:n { e } { T , F , TF }
\prg_set_eq_conditional:NNn \zrefclever_language_if_declared:n
  \__zrefclever_language_if_declared:n { TF }
\NewDocumentCommand \zcDeclareLanguage { O { } m }
  {
    \group_begin:
      \tl_if_empty:nF {#2}
        {
          \__zrefclever_language_if_declared:nTF {#2}
            { \msg_warning:nnn { zref-clever } { language-declared } {#2} }
            {
              \tl_new:c { \__zrefclever_language_varname:n {#2} }
              \tl_gset:cn { \__zrefclever_language_varname:n {#2} } {#2}
              \tl_set:Nn \l__zrefclever_setup_language_tl {#2}
              \keys_set:nn { zref-clever/declarelang } {#1}
            }
        }
    \group_end:
  }
\@onlypreamble \zcDeclareLanguage
\NewDocumentCommand \zcDeclareLanguageAlias { m m }
  {
    \tl_if_empty:nF {#1}
      {
        \__zrefclever_language_if_declared:nTF {#2}
          {
            \tl_new:c { \__zrefclever_language_varname:n {#1} }
            \tl_gset:ce { \__zrefclever_language_varname:n {#1} }
              { \tl_use:c { \__zrefclever_language_varname:n {#2} } }
          }
          { \msg_warning:nnn { zref-clever } { unknown-language-alias } {#2} }
      }
  }
\@onlypreamble \zcDeclareLanguageAlias
\keys_define:nn { zref-clever/declarelang }
  {
    variants .code:n =
      {
        \seq_new:c
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_setup_language_tl } { variants } { seq }
          }
        \seq_gset_from_clist:cn
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_setup_language_tl } { variants } { seq }
          }
          {#1}
      } ,
    variants .value_required:n = true ,
    % NOTE Option deprecated in 2024-11-24 for v0.5.0.
    declension .meta:n = { variants = {#1} } ,
    gender .code:n =
      {
        \seq_new:c
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_setup_language_tl } { gender } { seq }
          }
        \seq_gset_from_clist:cn
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_setup_language_tl } { gender } { seq }
          }
          {#1}
      } ,
    gender .value_required:n = true ,
    allcaps .choices:nn =
      { true , false }
      {
        \bool_new:c
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_setup_language_tl } { allcaps } { bool }
          }
        \use:c { bool_gset_ \l_keys_choice_tl :c }
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_setup_language_tl } { allcaps } { bool }
          }
      } ,
    allcaps .default:n = true ,
  }
\cs_new_protected:Npn \__zrefclever_process_language_settings:
  {
    \__zrefclever_language_if_declared:eTF
      { \l__zrefclever_ref_language_tl }
      {
        \__zrefclever_opt_seq_get:cNF
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_ref_language_tl } { variants } { seq }
          }
          \l__zrefclever_lang_variants_seq
          { \seq_clear:N \l__zrefclever_lang_variants_seq }
        \seq_if_empty:NTF \l__zrefclever_lang_variants_seq
          {
            \tl_if_empty:NF \l__zrefclever_ref_variant_tl
              {
                \msg_warning:nnee { zref-clever }
                  { language-no-variants-ref }
                  { \l__zrefclever_ref_language_tl }
                  { \l__zrefclever_ref_variant_tl }
                \tl_clear:N \l__zrefclever_ref_variant_tl
              }
          }
          {
            \tl_if_empty:NTF \l__zrefclever_ref_variant_tl
              {
                \seq_get_left:NN \l__zrefclever_lang_variants_seq
                  \l__zrefclever_ref_variant_tl
              }
              {
                \seq_if_in:NVF \l__zrefclever_lang_variants_seq
                  \l__zrefclever_ref_variant_tl
                  {
                    \msg_warning:nnee { zref-clever }
                      { unknown-variant }
                      { \l__zrefclever_ref_variant_tl }
                      { \l__zrefclever_ref_language_tl }
                    \seq_get_left:NN \l__zrefclever_lang_variants_seq
                      \l__zrefclever_ref_variant_tl
                  }
              }
          }
        \__zrefclever_opt_seq_get:cNF
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_ref_language_tl } { gender } { seq }
          }
          \l__zrefclever_lang_gender_seq
          { \seq_clear:N \l__zrefclever_lang_gender_seq }
        \seq_if_empty:NTF \l__zrefclever_lang_gender_seq
          {
            \tl_if_empty:NF \l__zrefclever_ref_gender_tl
              {
                \msg_warning:nneee { zref-clever }
                  { language-no-gender }
                  { \l__zrefclever_ref_language_tl }
                  { g }
                  { \l__zrefclever_ref_gender_tl }
                \tl_clear:N \l__zrefclever_ref_gender_tl
              }
          }
          {
            \tl_if_empty:NF \l__zrefclever_ref_gender_tl
              {
                \seq_if_in:NVF \l__zrefclever_lang_gender_seq
                  \l__zrefclever_ref_gender_tl
                  {
                    \msg_warning:nnee { zref-clever }
                      { gender-not-declared }
                      { \l__zrefclever_ref_language_tl }
                      { \l__zrefclever_ref_gender_tl }
                    \tl_clear:N \l__zrefclever_ref_gender_tl
                  }
              }
          }
        \__zrefclever_opt_bool_if:cT
          {
            \__zrefclever_opt_varname_language:enn
              { \l__zrefclever_ref_language_tl } { allcaps } { bool }
          }
          { \keys_set:nn { zref-clever/reference } { cap = true } }
      }
      {
        \tl_if_empty:NF \l__zrefclever_ref_variant_tl
          {
            \msg_warning:nnee { zref-clever } { unknown-language-variant }
              { \l__zrefclever_ref_variant_tl }
              { \l__zrefclever_ref_language_tl }
            \tl_clear:N \l__zrefclever_ref_variant_tl
          }
        \tl_if_empty:NF \l__zrefclever_ref_gender_tl
          {
            \msg_warning:nneee { zref-clever }
              { language-no-gender }
              { \l__zrefclever_ref_language_tl }
              { g }
              { \l__zrefclever_ref_gender_tl }
            \tl_clear:N \l__zrefclever_ref_gender_tl
          }
      }
  }
\seq_new:N \g__zrefclever_loaded_langfiles_seq
\cs_new_protected:Npn \__zrefclever_provide_langfile:n #1
  {
    \group_begin:
      \@bsphack
      \__zrefclever_language_if_declared:nT {#1}
        {
          \seq_if_in:NeF
            \g__zrefclever_loaded_langfiles_seq
            { \tl_use:c { \__zrefclever_language_varname:n {#1} } }
            {
              \exp_args:Ne \file_get:nnNTF
                {
                  zref-clever-
                  \tl_use:c { \__zrefclever_language_varname:n {#1} }
                  .lang
                }
                { \ExplSyntaxOn }
                \l__zrefclever_tmpa_tl
                {
                  \tl_set:Nn \l__zrefclever_setup_language_tl {#1}
                  \tl_clear:N \l__zrefclever_setup_type_tl
                  \__zrefclever_opt_seq_get:cNF
                    {
                      \__zrefclever_opt_varname_language:nnn
                        {#1} { variants } { seq }
                    }
                    \l__zrefclever_lang_variants_seq
                    { \seq_clear:N \l__zrefclever_lang_variants_seq }
                  \seq_if_empty:NTF \l__zrefclever_lang_variants_seq
                    { \tl_clear:N \l__zrefclever_lang_variant_tl }
                    {
                      \seq_get_left:NN \l__zrefclever_lang_variants_seq
                        \l__zrefclever_lang_variant_tl
                    }
                  \__zrefclever_opt_seq_get:cNF
                    {
                      \__zrefclever_opt_varname_language:nnn
                        {#1} { gender } { seq }
                    }
                    \l__zrefclever_lang_gender_seq
                    { \seq_clear:N \l__zrefclever_lang_gender_seq }
                  \keys_set:nV { zref-clever/langfile } \l__zrefclever_tmpa_tl
                  \seq_gput_right:Ne \g__zrefclever_loaded_langfiles_seq
                    { \tl_use:c { \__zrefclever_language_varname:n {#1} } }
                  \msg_info:nne { zref-clever } { langfile-loaded }
                    { \tl_use:c { \__zrefclever_language_varname:n {#1} } }
                }
                {
                  \seq_gput_right:Ne \g__zrefclever_loaded_langfiles_seq
                    { \tl_use:c { \__zrefclever_language_varname:n {#1} } }
                }
            }
        }
      \@esphack
    \group_end:
  }
\cs_generate_variant:Nn \__zrefclever_provide_langfile:n { e }
\keys_define:nn { zref-clever/langfile }
  {
    type .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \tl_clear:N \l__zrefclever_setup_type_tl }
          { \tl_set:Nn \l__zrefclever_setup_type_tl {#1} }
      } ,
    variant .code:n =
      {
        \seq_if_empty:NTF \l__zrefclever_lang_variants_seq
          {
            \msg_info:nnee { zref-clever } { language-no-variants-setup }
              { \l__zrefclever_setup_language_tl } {#1}
          }
          {
            \seq_if_in:NnTF \l__zrefclever_lang_variants_seq {#1}
              { \tl_set:Nn \l__zrefclever_lang_variant_tl {#1} }
              {
                \msg_info:nnee { zref-clever } { unknown-variant }
                  {#1} { \l__zrefclever_setup_language_tl }
                \seq_get_left:NN \l__zrefclever_lang_variants_seq
                  \l__zrefclever_lang_variant_tl
              }
          }
      } ,
    variant .value_required:n = true ,
    gender .value_required:n = true ,
    gender .code:n =
      {
        \seq_if_empty:NTF \l__zrefclever_lang_gender_seq
          {
            \msg_info:nneee { zref-clever } { language-no-gender }
              { \l__zrefclever_setup_language_tl } { gender } {#1}
          }
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \msg_info:nnn { zref-clever }
                  { option-only-type-specific } { gender }
              }
              {
                \seq_clear:N \l__zrefclever_tmpa_seq
                \clist_map_inline:nn {#1}
                  {
                    \seq_if_in:NnTF \l__zrefclever_lang_gender_seq {##1}
                      { \seq_put_right:Nn \l__zrefclever_tmpa_seq {##1} }
                      {
                        \msg_info:nnee { zref-clever }
                          { gender-not-declared }
                          { \l__zrefclever_setup_language_tl } {##1}
                      }
                  }
                \__zrefclever_opt_seq_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      { gender }
                      { seq }
                  }
                  {
                    \seq_new:c
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          { gender }
                          { seq }
                      }
                    \seq_gset_eq:cN
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          { gender }
                          { seq }
                      }
                      \l__zrefclever_tmpa_seq
                  }
              }
          }
      } ,
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_not_type_specific_seq
  {
    \keys_define:nn { zref-clever/langfile }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_tl_gset_if_new:cn
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl }
                      {#1} { tl }
                  }
                  {##1}
              }
              {
                \msg_info:nnn { zref-clever }
                  { option-not-type-specific } {#1}
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_maybe_type_specific_seq
  {
    \keys_define:nn { zref-clever/langfile }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_tl_gset_if_new:cn
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl }
                      {#1} { tl }
                  }
                  {##1}
              }
              {
                \__zrefclever_opt_tl_gset_if_new:cn
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      {#1} { tl }
                  }
                  {##1}
              }
          } ,
      }
  }
\keys_define:nn { zref-clever/langfile }
  {
    endrange .value_required:n = true ,
    endrange .code:n =
      {
        \str_case:nnF {#1}
          {
            { ref }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
            { stripprefix }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gset_if_new:cn
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_stripprefix }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gset_if_new:cn
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_stripprefix }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
            { pagecomp }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gset_if_new:cn
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomp }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gset_if_new:cn
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomp }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
            { pagecomp2 }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gset_if_new:cn
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomptwo }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gset_if_new:cn
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomptwo }
                  \__zrefclever_opt_tl_gclear_if_new:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
          }
          {
            \tl_if_empty:nTF {#1}
              {
                \msg_info:nnn { zref-clever }
                  { endrange-property-undefined } {#1}
              }
              {
                \zref@ifpropundefined {#1}
                  {
                    \msg_info:nnn { zref-clever }
                      { endrange-property-undefined } {#1}
                  }
                  {
                    \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                      {
                        \__zrefclever_opt_tl_gset_if_new:cn
                          {
                            \__zrefclever_opt_varname_lang_default:enn
                              { \l__zrefclever_setup_language_tl }
                              { endrangefunc } { tl }
                          }
                          { __zrefclever_get_endrange_property }
                        \__zrefclever_opt_tl_gset_if_new:cn
                          {
                            \__zrefclever_opt_varname_lang_default:enn
                              { \l__zrefclever_setup_language_tl }
                              { endrangeprop } { tl }
                          }
                          {#1}
                      }
                      {
                        \__zrefclever_opt_tl_gset_if_new:cn
                          {
                            \__zrefclever_opt_varname_lang_type:eenn
                              { \l__zrefclever_setup_language_tl }
                              { \l__zrefclever_setup_type_tl }
                              { endrangefunc } { tl }
                          }
                          { __zrefclever_get_endrange_property }
                        \__zrefclever_opt_tl_gset_if_new:cn
                          {
                            \__zrefclever_opt_varname_lang_type:eenn
                              { \l__zrefclever_setup_language_tl }
                              { \l__zrefclever_setup_type_tl }
                              { endrangeprop } { tl }
                          }
                          {#1}
                      }
                  }
              }
          }
      } ,
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_type_names_seq
  {
    \keys_define:nn { zref-clever/langfile }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \msg_info:nnn { zref-clever }
                  { option-only-type-specific } {#1}
              }
              {
                \tl_if_empty:NTF \l__zrefclever_lang_variant_tl
                  {
                    \__zrefclever_opt_tl_gset_if_new:cn
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          {#1} { tl }
                      }
                      {##1}
                  }
                  {
                    \__zrefclever_opt_tl_gset_if_new:cn
                      {
                        \__zrefclever_opt_varname_lang_type:eeen
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          { \l__zrefclever_lang_variant_tl - #1 } { tl }
                      }
                      {##1}
                  }
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_seq_refbounds_seq
  {
    \keys_define:nn { zref-clever/langfile }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_seq_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl } {#1} { seq }
                  }
                  {
                    \seq_gclear:N \g__zrefclever_tmpa_seq
                    \__zrefclever_opt_seq_gset_clist_split:Nn
                      \g__zrefclever_tmpa_seq {##1}
                    \bool_lazy_or:nnTF
                      { \tl_if_empty_p:n {##1} }
                      {
                        \int_compare_p:nNn
                          { \seq_count:N \g__zrefclever_tmpa_seq } = { 4 }
                      }
                      {
                        \__zrefclever_opt_seq_gset_eq:cN
                          {
                            \__zrefclever_opt_varname_lang_default:enn
                              { \l__zrefclever_setup_language_tl }
                              {#1} { seq }
                          }
                          \g__zrefclever_tmpa_seq
                      }
                      {
                        \msg_info:nnee { zref-clever }
                          { refbounds-must-be-four }
                          {#1} { \seq_count:N \g__zrefclever_tmpa_seq }
                      }
                  }
              }
              {
                \__zrefclever_opt_seq_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl } {#1} { seq }
                  }
                  {
                    \seq_gclear:N \g__zrefclever_tmpa_seq
                    \__zrefclever_opt_seq_gset_clist_split:Nn
                      \g__zrefclever_tmpa_seq {##1}
                    \bool_lazy_or:nnTF
                      { \tl_if_empty_p:n {##1} }
                      {
                        \int_compare_p:nNn
                          { \seq_count:N \g__zrefclever_tmpa_seq } = { 4 }
                      }
                      {
                        \__zrefclever_opt_seq_gset_eq:cN
                          {
                            \__zrefclever_opt_varname_lang_type:eenn
                              { \l__zrefclever_setup_language_tl }
                              { \l__zrefclever_setup_type_tl }
                              {#1} { seq }
                          }
                          \g__zrefclever_tmpa_seq
                      }
                      {
                        \msg_info:nnee { zref-clever }
                          { refbounds-must-be-four }
                          {#1} { \seq_count:N \g__zrefclever_tmpa_seq }
                      }
                  }
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_bool_maybe_type_specific_seq
  {
    \keys_define:nn { zref-clever/langfile }
      {
        #1 .choice: ,
        #1 / true .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_bool_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl }
                      {#1} { bool }
                  }
                  {
                    \__zrefclever_opt_bool_gset_true:c
                      {
                        \__zrefclever_opt_varname_lang_default:enn
                          { \l__zrefclever_setup_language_tl }
                          {#1} { bool }
                      }
                  }
              }
              {
                \__zrefclever_opt_bool_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      {#1} { bool }
                  }
                  {
                    \__zrefclever_opt_bool_gset_true:c
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          {#1} { bool }
                      }
                  }
              }
          } ,
        #1 / false .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_bool_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl }
                      {#1} { bool }
                  }
                  {
                    \__zrefclever_opt_bool_gset_false:c
                      {
                        \__zrefclever_opt_varname_lang_default:enn
                          { \l__zrefclever_setup_language_tl }
                          {#1} { bool }
                      }
                  }
              }
              {
                \__zrefclever_opt_bool_if_set:cF
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      {#1} { bool }
                  }
                  {
                    \__zrefclever_opt_bool_gset_false:c
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          {#1} { bool }
                      }
                  }
              }
          } ,
        #1 .default:n = true ,
        no #1 .meta:n = { #1 = false } ,
        no #1 .value_forbidden:n = true ,
      }
  }
\cs_new_protected:Npn \__zrefclever_opt_tl_cset_fallback:nn #1#2
  {
    \tl_const:cn
      { \__zrefclever_opt_varname_fallback:nn {#1} { tl } } {#2}
  }
\keyval_parse:nnn
  { }
  { \__zrefclever_opt_tl_cset_fallback:nn }
  {
    tpairsep  = {,~} ,
    tlistsep  = {,~} ,
    tlastsep  = {,~} ,
    notesep   = {~} ,
    namesep   = {\nobreakspace} ,
    pairsep   = {,~} ,
    listsep   = {,~} ,
    lastsep   = {,~} ,
    rangesep  = {\textendash} ,
  }
\cs_new_protected:Npn \__zrefclever_prop_put_non_empty:Nnn #1#2#3
  {
    \tl_if_empty:nTF {#3}
      { \prop_remove:Nn #1 {#2} }
      { \prop_put:Nnn #1 {#2} {#3} }
  }
\tl_new:N \l__zrefclever_ref_property_tl
\keys_define:nn { zref-clever/reference }
  {
    ref .code:n =
      {
        \tl_if_empty:nTF {#1}
          {
            \msg_warning:nnn { zref-clever }
              { zref-property-undefined } {#1}
            \tl_set:Nn \l__zrefclever_ref_property_tl { default }
          }
          {
            \zref@ifpropundefined {#1}
              {
                \msg_warning:nnn { zref-clever }
                  { zref-property-undefined } {#1}
                \tl_set:Nn \l__zrefclever_ref_property_tl { default }
              }
              { \tl_set:Nn \l__zrefclever_ref_property_tl {#1} }
          }
      } ,
    ref .initial:n = default ,
    ref .value_required:n = true ,
    page .meta:n = { ref = page },
    page .value_forbidden:n = true ,
  }
\bool_new:N \l__zrefclever_typeset_ref_bool
\bool_new:N \l__zrefclever_typeset_name_bool
\keys_define:nn { zref-clever/reference }
  {
    typeset .choice: ,
    typeset / both .code:n =
      {
        \bool_set_true:N \l__zrefclever_typeset_ref_bool
        \bool_set_true:N \l__zrefclever_typeset_name_bool
      } ,
    typeset / ref .code:n =
      {
        \bool_set_true:N \l__zrefclever_typeset_ref_bool
        \bool_set_false:N \l__zrefclever_typeset_name_bool
      } ,
    typeset / name .code:n =
      {
        \bool_set_false:N \l__zrefclever_typeset_ref_bool
        \bool_set_true:N \l__zrefclever_typeset_name_bool
      } ,
    typeset .initial:n = both ,
    typeset .value_required:n = true ,
    noname .meta:n = { typeset = ref } ,
    noname .value_forbidden:n = true ,
    noref .meta:n = { typeset = name } ,
    noref .value_forbidden:n = true ,
  }
\bool_new:N \l__zrefclever_typeset_sort_bool
\keys_define:nn { zref-clever/reference }
  {
    sort .bool_set:N = \l__zrefclever_typeset_sort_bool ,
    sort .initial:n = true ,
    sort .default:n = true ,
    nosort .meta:n = { sort = false },
    nosort .value_forbidden:n = true ,
  }
\seq_new:N \l__zrefclever_typesort_seq
\keys_define:nn { zref-clever/reference }
  {
    typesort .code:n =
      {
        \seq_set_from_clist:Nn \l__zrefclever_typesort_seq {#1}
        \seq_reverse:N \l__zrefclever_typesort_seq
      } ,
    typesort .initial:n =
      { part , chapter , section , paragraph },
    typesort .value_required:n = true ,
    notypesort .code:n =
      { \seq_clear:N \l__zrefclever_typesort_seq } ,
    notypesort .value_forbidden:n = true ,
  }
\bool_new:N \l__zrefclever_typeset_compress_bool
\keys_define:nn { zref-clever/reference }
  {
    comp .bool_set:N = \l__zrefclever_typeset_compress_bool ,
    comp .initial:n = true ,
    comp .default:n = true ,
    nocomp .meta:n = { comp = false },
    nocomp .value_forbidden:n = true ,
  }
\NewHook { zref-clever/endrange-setup }
\keys_define:nn { zref-clever/reference }
  {
    endrange .code:n =
      {
        \str_case:nnF {#1}
          {
            { ref }
            {
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangefunc } { tl }
                }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangeprop } { tl }
                }
            }
            { stripprefix }
            {
              \__zrefclever_opt_tl_set:cn
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangefunc } { tl }
                }
                { __zrefclever_get_endrange_stripprefix }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangeprop } { tl }
                }
            }
            { pagecomp }
            {
              \__zrefclever_opt_tl_set:cn
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangefunc } { tl }
                }
                { __zrefclever_get_endrange_pagecomp }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangeprop } { tl }
                }
            }
            { pagecomp2 }
            {
              \__zrefclever_opt_tl_set:cn
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangefunc } { tl }
                }
                { __zrefclever_get_endrange_pagecomptwo }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangeprop } { tl }
                }
            }
            { unset }
            {
              \__zrefclever_opt_tl_unset:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangefunc } { tl }
                }
              \__zrefclever_opt_tl_unset:c
                {
                  \__zrefclever_opt_varname_general:nn
                    { endrangeprop } { tl }
                }
            }
          }
          {
            \tl_if_empty:nTF {#1}
              {
                \msg_warning:nnn { zref-clever }
                  { endrange-property-undefined } {#1}
              }
              {
                \zref@ifpropundefined {#1}
                  {
                    \msg_warning:nnn { zref-clever }
                      { endrange-property-undefined } {#1}
                  }
                  {
                    \__zrefclever_opt_tl_set:cn
                      {
                        \__zrefclever_opt_varname_general:nn
                          { endrangefunc } { tl }
                      }
                      { __zrefclever_get_endrange_property }
                    \__zrefclever_opt_tl_set:cn
                      {
                        \__zrefclever_opt_varname_general:nn
                          { endrangeprop } { tl }
                      }
                      {#1}
                  }
              }
          }
      } ,
    endrange .value_required:n = true ,
  }
\cs_new_protected:Npn \__zrefclever_get_endrange_property:nnN #1#2#3
  {
    \tl_if_empty:NTF \l__zrefclever_endrangeprop_tl
      {
        \zref@ifrefcontainsprop {#2} { \l__zrefclever_ref_property_tl }
          {
            \__zrefclever_extract_default:Nnvn #3
              {#2} { l__zrefclever_ref_property_tl } { }
          }
          { \tl_set:Nn #3 { zc@missingproperty } }
      }
      {
        \zref@ifrefcontainsprop {#2} { \l__zrefclever_endrangeprop_tl }
          {
            \bool_if:NTF \l__zrefclever_typeset_range_bool
              {
                \group_begin:
                  \bool_set_false:N \l__zrefclever_tmpa_bool
                  \exp_args:Nee \tl_if_eq:nnT
                    {
                      \__zrefclever_extract_unexp:nnn
                        {#1} { externaldocument } { }
                    }
                    {
                      \__zrefclever_extract_unexp:nnn
                        {#2} { externaldocument } { }
                    }
                    {
                      \tl_if_eq:NnTF \l__zrefclever_ref_property_tl { page }
                        {
                          \exp_args:Nee \tl_if_eq:nnT
                            {
                              \__zrefclever_extract_unexp:nnn
                                {#1} { zc@pgfmt } { }
                            }
                            {
                              \__zrefclever_extract_unexp:nnn
                                {#2} { zc@pgfmt } { }
                            }
                            { \bool_set_true:N \l__zrefclever_tmpa_bool }
                        }
                        {
                          \exp_args:Nee \tl_if_eq:nnT
                            {
                              \__zrefclever_extract_unexp:nnn
                                {#1} { zc@counter } { }
                            }
                            {
                              \__zrefclever_extract_unexp:nnn
                                {#2} { zc@counter } { }
                            }
                            {
                              \exp_args:Nee \tl_if_eq:nnT
                                {
                                  \__zrefclever_extract_unexp:nnn
                                    {#1} { zc@enclval } { }
                                }
                                {
                                  \__zrefclever_extract_unexp:nnn
                                    {#2} { zc@enclval } { }
                                }
                                { \bool_set_true:N \l__zrefclever_tmpa_bool }
                            }
                        }
                    }
                  \bool_if:NTF \l__zrefclever_tmpa_bool
                    {
                      \__zrefclever_extract_default:Nnvn \l__zrefclever_tmpb_tl
                        {#2} { l__zrefclever_endrangeprop_tl } { }
                    }
                    {
                      \zref@ifrefcontainsprop
                        {#2} { \l__zrefclever_ref_property_tl }
                        {
                          \__zrefclever_extract_default:Nnvn \l__zrefclever_tmpb_tl
                            {#2} { l__zrefclever_ref_property_tl } { }
                        }
                        { \tl_set:Nn \l__zrefclever_tmpb_tl { zc@missingproperty } }
                    }
                  \exp_args:NNNV
                    \group_end:
                    \tl_set:Nn #3 \l__zrefclever_tmpb_tl
              }
              {
                \__zrefclever_extract_default:Nnvn #3
                  {#2} { l__zrefclever_endrangeprop_tl } { }
              }
          }
          {
            \zref@ifrefcontainsprop {#2} { \l__zrefclever_ref_property_tl }
              {
                \__zrefclever_extract_default:Nnvn #3
                  {#2} { l__zrefclever_ref_property_tl } { }
              }
              { \tl_set:Nn #3 { zc@missingproperty } }
          }
      }
  }
\cs_generate_variant:Nn \__zrefclever_get_endrange_property:nnN { VVN }
\cs_new_protected:Npn \__zrefclever_get_endrange_stripprefix:nnN #1#2#3
  {
    \zref@ifrefcontainsprop {#2} { \l__zrefclever_ref_property_tl }
      {
        \group_begin:
          \UseHook { zref-clever/endrange-setup }
          \protected@edef \l__zrefclever_tmpa_tl
            {
              \__zrefclever_extract:nnn
                {#1} { \l__zrefclever_ref_property_tl } { }
            }
          \protected@edef \l__zrefclever_tmpb_tl
            {
              \__zrefclever_extract:nnn
                {#2} { \l__zrefclever_ref_property_tl } { }
            }
          \bool_set_false:N \l__zrefclever_tmpa_bool
          \bool_until_do:Nn \l__zrefclever_tmpa_bool
            {
              \exp_args:Nee \tl_if_eq:nnTF
                { \tl_head:V \l__zrefclever_tmpa_tl }
                { \tl_head:V \l__zrefclever_tmpb_tl }
                {
                  \tl_set:Ne \l__zrefclever_tmpa_tl
                    { \tl_tail:V \l__zrefclever_tmpa_tl }
                  \tl_set:Ne \l__zrefclever_tmpb_tl
                    { \tl_tail:V \l__zrefclever_tmpb_tl }
                  \tl_if_empty:NT \l__zrefclever_tmpb_tl
                    { \bool_set_true:N \l__zrefclever_tmpa_bool }
                }
                { \bool_set_true:N \l__zrefclever_tmpa_bool }
            }
          \exp_args:NNNV
            \group_end:
            \tl_set:Nn #3 \l__zrefclever_tmpb_tl
      }
      { \tl_set:Nn #3 { zc@missingproperty } }
  }
\cs_generate_variant:Nn \__zrefclever_get_endrange_stripprefix:nnN { VVN }
\prg_new_protected_conditional:Npnn
  \__zrefclever_is_integer_rgx:n #1 { F , TF }
  {
    \regex_match:nnTF { \A\d+\Z } {#1}
      { \prg_return_true:  }
      { \prg_return_false: }
  }
\prg_generate_conditional_variant:Nnn
  \__zrefclever_is_integer_rgx:n { V } { F , TF }
\cs_new_protected:Npn \__zrefclever_get_endrange_pagecomp:nnN #1#2#3
  {
    \zref@ifrefcontainsprop {#2} { \l__zrefclever_ref_property_tl }
      {
        \group_begin:
          \UseHook { zref-clever/endrange-setup }
          \protected@edef \l__zrefclever_tmpa_tl
            {
              \__zrefclever_extract:nnn
                {#1} { \l__zrefclever_ref_property_tl } { }
            }
          \protected@edef \l__zrefclever_tmpb_tl
            {
              \__zrefclever_extract:nnn
                {#2} { \l__zrefclever_ref_property_tl } { }
            }
          \bool_set_false:N \l__zrefclever_tmpa_bool
          \__zrefclever_is_integer_rgx:VTF \l__zrefclever_tmpa_tl
            {
              \__zrefclever_is_integer_rgx:VF \l__zrefclever_tmpb_tl
                { \bool_set_true:N \l__zrefclever_tmpa_bool }
            }
            { \bool_set_true:N \l__zrefclever_tmpa_bool }
          \bool_until_do:Nn \l__zrefclever_tmpa_bool
            {
              \exp_args:Nee \tl_if_eq:nnTF
                { \tl_head:V \l__zrefclever_tmpa_tl }
                { \tl_head:V \l__zrefclever_tmpb_tl }
                {
                  \tl_set:Ne \l__zrefclever_tmpa_tl
                    { \tl_tail:V \l__zrefclever_tmpa_tl }
                  \tl_set:Ne \l__zrefclever_tmpb_tl
                    { \tl_tail:V \l__zrefclever_tmpb_tl }
                  \tl_if_empty:NT \l__zrefclever_tmpb_tl
                    { \bool_set_true:N \l__zrefclever_tmpa_bool }
                }
                { \bool_set_true:N \l__zrefclever_tmpa_bool }
            }
          \exp_args:NNNV
            \group_end:
            \tl_set:Nn #3 \l__zrefclever_tmpb_tl
      }
      { \tl_set:Nn #3 { zc@missingproperty } }
  }
\cs_generate_variant:Nn \__zrefclever_get_endrange_pagecomp:nnN { VVN }
\cs_new_protected:Npn \__zrefclever_get_endrange_pagecomptwo:nnN #1#2#3
  {
    \zref@ifrefcontainsprop {#2} { \l__zrefclever_ref_property_tl }
      {
        \group_begin:
          \UseHook { zref-clever/endrange-setup }
          \protected@edef \l__zrefclever_tmpa_tl
            {
              \__zrefclever_extract:nnn
                {#1} { \l__zrefclever_ref_property_tl } { }
            }
          \protected@edef \l__zrefclever_tmpb_tl
            {
              \__zrefclever_extract:nnn
                {#2} { \l__zrefclever_ref_property_tl } { }
            }
          \bool_set_false:N \l__zrefclever_tmpa_bool
          \__zrefclever_is_integer_rgx:VTF \l__zrefclever_tmpa_tl
            {
              \__zrefclever_is_integer_rgx:VF \l__zrefclever_tmpb_tl
                { \bool_set_true:N \l__zrefclever_tmpa_bool }
            }
            { \bool_set_true:N \l__zrefclever_tmpa_bool }
          \bool_until_do:Nn \l__zrefclever_tmpa_bool
            {
              \exp_args:Nee \tl_if_eq:nnTF
                { \tl_head:V \l__zrefclever_tmpa_tl }
                { \tl_head:V \l__zrefclever_tmpb_tl }
                {
                  \bool_lazy_or:nnTF
                    { \int_compare_p:nNn { \l__zrefclever_tmpb_tl } > { 99 } }
                    {
                      \int_compare_p:nNn
                        { \tl_head:V \l__zrefclever_tmpb_tl } = { 0 }
                    }
                    {
                      \tl_set:Ne \l__zrefclever_tmpa_tl
                        { \tl_tail:V \l__zrefclever_tmpa_tl }
                      \tl_set:Ne \l__zrefclever_tmpb_tl
                        { \tl_tail:V \l__zrefclever_tmpb_tl }
                    }
                    { \bool_set_true:N \l__zrefclever_tmpa_bool }
                }
                { \bool_set_true:N \l__zrefclever_tmpa_bool }
            }
          \exp_args:NNNV
            \group_end:
            \tl_set:Nn #3 \l__zrefclever_tmpb_tl
      }
      { \tl_set:Nn #3 { zc@missingproperty } }
  }
\cs_generate_variant:Nn \__zrefclever_get_endrange_pagecomptwo:nnN { VVN }
\bool_new:N \l__zrefclever_typeset_range_bool
\keys_define:nn { zref-clever/reference }
  {
    range .bool_set:N = \l__zrefclever_typeset_range_bool ,
    range .initial:n = false ,
    range .default:n = true ,
  }
\bool_new:N \l__zrefclever_capfirst_bool
\keys_define:nn { zref-clever/reference }
  {
    capfirst .bool_set:N = \l__zrefclever_capfirst_bool ,
    capfirst .initial:n = false ,
    capfirst .default:n = true ,
  }
\bool_new:N \l__zrefclever_noabbrev_first_bool
\keys_define:nn { zref-clever/reference }
  {
    noabbrevfirst .bool_set:N = \l__zrefclever_noabbrev_first_bool ,
    noabbrevfirst .initial:n = false ,
    noabbrevfirst .default:n = true ,
  }
\keys_define:nn { zref-clever/reference }
  {
    S .meta:n =
      { capfirst = {#1} , noabbrevfirst = {#1} },
    S .default:n = true ,
  }
\bool_new:N \l__zrefclever_hyperlink_bool
\bool_new:N \l__zrefclever_hyperref_warn_bool
\keys_define:nn { zref-clever/reference }
  {
    hyperref .choice: ,
    hyperref / auto .code:n =
      {
        \bool_set_true:N \l__zrefclever_hyperlink_bool
        \bool_set_false:N \l__zrefclever_hyperref_warn_bool
      } ,
    hyperref / true .code:n =
      {
        \bool_set_true:N \l__zrefclever_hyperlink_bool
        \bool_set_true:N \l__zrefclever_hyperref_warn_bool
      } ,
    hyperref / false .code:n =
      {
        \bool_set_false:N \l__zrefclever_hyperlink_bool
        \bool_set_false:N \l__zrefclever_hyperref_warn_bool
      } ,
    hyperref .initial:n = auto ,
    hyperref .default:n = true ,
    nohyperref .meta:n = { hyperref = false } ,
    nohyperref .value_forbidden:n = true ,
  }
\AddToHook { begindocument }
  {
    \__zrefclever_if_package_loaded:nTF { hyperref }
      {
        \bool_if:NT \l__zrefclever_hyperlink_bool
          { \RequirePackage { zref-hyperref } }
      }
      {
        \bool_if:NT \l__zrefclever_hyperref_warn_bool
          { \msg_warning:nn { zref-clever } { missing-hyperref } }
        \bool_set_false:N \l__zrefclever_hyperlink_bool
      }
    \keys_define:nn { zref-clever/reference }
      {
        hyperref .code:n =
          { \msg_warning:nn { zref-clever } { hyperref-preamble-only } } ,
        nohyperref .code:n =
          { \bool_set_false:N \l__zrefclever_hyperlink_bool } ,
      }
  }
\str_new:N \l__zrefclever_nameinlink_str
\keys_define:nn { zref-clever/reference }
  {
    nameinlink .choice: ,
    nameinlink / true .code:n =
      { \str_set:Nn \l__zrefclever_nameinlink_str { true } } ,
    nameinlink / false .code:n =
      { \str_set:Nn \l__zrefclever_nameinlink_str { false } } ,
    nameinlink / single .code:n =
      { \str_set:Nn \l__zrefclever_nameinlink_str { single } } ,
    nameinlink / tsingle .code:n =
      { \str_set:Nn \l__zrefclever_nameinlink_str { tsingle } } ,
    nameinlink .initial:n = tsingle ,
    nameinlink .default:n = true ,
  }
\keys_define:nn { zref-clever/reference }
  {
    preposinlink .code:n =
      {
        % NOTE Option deprecated in 2022-01-12 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { preposinlink } { refbounds }
      } ,
  }
\AddToHook { begindocument }
  {
    \__zrefclever_if_package_loaded:nTF { babel }
      {
        \tl_set:Nn \l__zrefclever_current_language_tl { \languagename }
        \tl_set:Nn \l__zrefclever_main_language_tl { \bbl@main@language }
      }
      {
        \__zrefclever_if_package_loaded:nTF { polyglossia }
          {
            \tl_set:Nn \l__zrefclever_current_language_tl { \babelname }
            \tl_set:Nn \l__zrefclever_main_language_tl { \mainbabelname }
          }
          {
            \tl_set:Nn \l__zrefclever_current_language_tl { english }
            \tl_set:Nn \l__zrefclever_main_language_tl { english }
          }
      }
  }
\keys_define:nn { zref-clever/reference }
  {
    lang .code:n =
      {
        \AddToHook { begindocument }
          {
            \str_case:nnF {#1}
              {
                { current }
                {
                  \tl_set:Nn \l__zrefclever_ref_language_tl
                    { \l__zrefclever_current_language_tl }
                }
                { main }
                {
                  \tl_set:Nn \l__zrefclever_ref_language_tl
                    { \l__zrefclever_main_language_tl }
                }
              }
              {
                \tl_set:Nn \l__zrefclever_ref_language_tl {#1}
                \__zrefclever_language_if_declared:nF {#1}
                  {
                    \msg_warning:nnn { zref-clever }
                      { unknown-language-opt } {#1}
                  }
              }
            \__zrefclever_provide_langfile:e
              { \l__zrefclever_ref_language_tl }
          }
      } ,
    lang .initial:n = current ,
    lang .value_required:n = true ,
  }
\AddToHook { begindocument / before }
  {
    \AddToHook { begindocument }
      {
        \keys_define:nn { zref-clever/reference }
          {
            lang .code:n =
              {
                \str_case:nnF {#1}
                  {
                    { current }
                    {
                      \tl_set:Nn \l__zrefclever_ref_language_tl
                        { \l__zrefclever_current_language_tl }
                    }
                    { main }
                    {
                      \tl_set:Nn \l__zrefclever_ref_language_tl
                        { \l__zrefclever_main_language_tl }
                    }
                  }
                  {
                    \tl_set:Nn \l__zrefclever_ref_language_tl {#1}
                    \__zrefclever_language_if_declared:nF {#1}
                      {
                        \msg_warning:nnn { zref-clever }
                          { unknown-language-opt } {#1}
                      }
                  }
              } ,
          }
      }
  }
\tl_new:N \l__zrefclever_ref_variant_tl
\keys_define:nn { zref-clever/reference }
  {
    v .code:n =
      { \msg_warning:nnn { zref-clever } { option-document-only } { v } } ,
    % NOTE Option deprecated in 2024-11-24 for v0.5.0.
    d .meta:n = { v = {#1} } ,
  }
\AddToHook { begindocument }
  {
    \keys_define:nn { zref-clever/reference }
      {
        v .tl_set:N = \l__zrefclever_ref_variant_tl ,
        v .value_required:n = true ,
        % NOTE Option deprecated in 2024-11-24 for v0.5.0.
        d .meta:n = { v = {#1} } ,
      }
  }
\bool_new:N \l__zrefclever_nudge_enabled_bool
\bool_new:N \l__zrefclever_nudge_multitype_bool
\bool_new:N \l__zrefclever_nudge_comptosing_bool
\bool_new:N \l__zrefclever_nudge_singular_bool
\bool_new:N \l__zrefclever_nudge_gender_bool
\tl_new:N \l__zrefclever_ref_gender_tl
\keys_define:nn { zref-clever/reference }
  {
    nudge .choice: ,
    nudge / true .code:n =
      { \bool_set_true:N \l__zrefclever_nudge_enabled_bool } ,
    nudge / false .code:n =
      { \bool_set_false:N \l__zrefclever_nudge_enabled_bool } ,
    nudge / ifdraft .code:n =
      {
        \ifdraft
          { \bool_set_false:N \l__zrefclever_nudge_enabled_bool }
          { \bool_set_true:N \l__zrefclever_nudge_enabled_bool }
      } ,
    nudge / iffinal .code:n =
      {
        \ifoptionfinal
          { \bool_set_true:N \l__zrefclever_nudge_enabled_bool }
          { \bool_set_false:N \l__zrefclever_nudge_enabled_bool }
      } ,
    nudge .initial:n = false ,
    nudge .default:n = true ,
    nonudge .meta:n = { nudge = false } ,
    nonudge .value_forbidden:n = true ,
    nudgeif .code:n =
      {
        \bool_set_false:N \l__zrefclever_nudge_multitype_bool
        \bool_set_false:N \l__zrefclever_nudge_comptosing_bool
        \bool_set_false:N \l__zrefclever_nudge_gender_bool
        \clist_map_inline:nn {#1}
          {
            \str_case:nnF {##1}
              {
                { multitype }
                { \bool_set_true:N \l__zrefclever_nudge_multitype_bool }
                { comptosing }
                { \bool_set_true:N \l__zrefclever_nudge_comptosing_bool }
                { gender }
                { \bool_set_true:N \l__zrefclever_nudge_gender_bool }
                { all }
                {
                  \bool_set_true:N \l__zrefclever_nudge_multitype_bool
                  \bool_set_true:N \l__zrefclever_nudge_comptosing_bool
                  \bool_set_true:N \l__zrefclever_nudge_gender_bool
                }
              }
              {
                \msg_warning:nnn { zref-clever }
                  { nudgeif-unknown-value } {##1}
              }
          }
      } ,
    nudgeif .value_required:n = true ,
    nudgeif .initial:n = all ,
    sg .bool_set:N = \l__zrefclever_nudge_singular_bool ,
    sg .initial:n = false ,
    sg .default:n = true ,
    g .code:n =
      { \msg_warning:nnn { zref-clever } { option-document-only } { g } } ,
  }
\AddToHook { begindocument }
  {
    \keys_define:nn { zref-clever/reference }
      {
        g .tl_set:N = \l__zrefclever_ref_gender_tl ,
        g .value_required:n = true ,
      }
  }
\tl_new:N \l__zrefclever_ref_typeset_font_tl
\keys_define:nn { zref-clever/reference }
  { font .tl_set:N = \l__zrefclever_ref_typeset_font_tl }
\keys_define:nn { zref-clever/reference }
  {
    titleref .code:n =
      {
        % NOTE Option deprecated in 2022-04-22 for 0.3.0.
        \msg_warning:nnee { zref-clever }{ option-deprecated } { titleref }
          { \iow_char:N\\usepackage\iow_char:N\{zref-titleref\iow_char:N\} }
      } ,
  }
\keys_define:nn { zref-clever/reference }
  {
    vario .code:n =
      {
        % NOTE Option deprecated in 2022-04-22 for 0.3.0.
        \msg_warning:nnee { zref-clever }{ option-deprecated } { vario }
          { \iow_char:N\\usepackage\iow_char:N\{zref-vario\iow_char:N\} }
      } ,
  }
\tl_new:N \l__zrefclever_zcref_note_tl
\keys_define:nn { zref-clever/reference }
  {
    note .tl_set:N = \l__zrefclever_zcref_note_tl ,
    note .value_required:n = true ,
  }
\bool_new:N \l__zrefclever_zrefcheck_available_bool
\bool_new:N \l__zrefclever_zcref_with_check_bool
\keys_define:nn { zref-clever/reference }
  {
    check .code:n =
      { \msg_warning:nnn { zref-clever } { option-document-only } { check } } ,
  }
\AddToHook { begindocument }
  {
    \__zrefclever_if_package_loaded:nTF { zref-check }
      {
        \IfPackageAtLeastTF { zref-check } { 2021-09-16 }
          {
            \bool_set_true:N \l__zrefclever_zrefcheck_available_bool
            \keys_define:nn { zref-clever/reference }
              {
                check .code:n =
                  {
                    \bool_set_true:N \l__zrefclever_zcref_with_check_bool
                    \keys_set:nn { zref-check/zcheck } {#1}
                  } ,
                check .value_required:n = true ,
              }
          }
          {
            \bool_set_false:N \l__zrefclever_zrefcheck_available_bool
            \keys_define:nn { zref-clever/reference }
              {
                check .code:n =
                  {
                    \msg_warning:nnn { zref-clever }
                      { zref-check-too-old } { 2021-09-16~v0.2.1 }
                  } ,
              }
          }
      }
      {
        \bool_set_false:N \l__zrefclever_zrefcheck_available_bool
        \keys_define:nn { zref-clever/reference }
          {
            check .code:n =
              { \msg_warning:nn { zref-clever } { missing-zref-check } } ,
          }
      }
  }
\tl_new:N \l__zrefclever_reftype_override_tl
\keys_define:nn { zref-clever/label }
  {
    reftype .tl_set:N = \l__zrefclever_reftype_override_tl ,
    reftype .default:n = {} ,
    reftype .initial:n = {} ,
  }
\prop_new:N \l__zrefclever_counter_type_prop
\keys_define:nn { zref-clever/label }
  {
    countertype .code:n =
      {
        \keyval_parse:nnn
          {
            \msg_warning:nnnn { zref-clever }
              { key-requires-value } { countertype }
          }
          {
            \__zrefclever_prop_put_non_empty:Nnn
              \l__zrefclever_counter_type_prop
          }
          {#1}
      } ,
    countertype .value_required:n = true ,
    countertype .initial:n =
      {
        subsection    = section ,
        subsubsection = section ,
        subparagraph  = paragraph ,
        enumi         = item ,
        enumii        = item ,
        enumiii       = item ,
        enumiv        = item ,
        mpfootnote    = footnote ,
      } ,
  }
\seq_new:N \l__zrefclever_counter_resetters_seq
\keys_define:nn { zref-clever/label }
  {
    counterresetters .code:n =
      { \seq_set_from_clist:Nn \l__zrefclever_counter_resetters_seq {#1} } ,
    counterresetters .initial:n =
      {
        subparagraph ,
        paragraph ,
        subsubsection ,
        subsection ,
        section ,
        chapter ,
        part ,
      },
    counterresetters .value_required:n = true ,
  }
\prop_new:N \l__zrefclever_counter_resetby_prop
\keys_define:nn { zref-clever/label }
  {
    counterresetby .code:n =
      {
        \keyval_parse:nnn
          {
            \msg_warning:nnn { zref-clever }
              { key-requires-value } { counterresetby }
          }
          {
            \__zrefclever_prop_put_non_empty:Nnn
              \l__zrefclever_counter_resetby_prop
          }
          {#1}
      } ,
    counterresetby .value_required:n = true ,
    counterresetby .initial:n =
      {
        enumii  = enumi   ,
        enumiii = enumii  ,
        enumiv  = enumiii ,
      } ,
  }
\tl_new:N \l__zrefclever_current_counter_tl
\keys_define:nn { zref-clever/label }
  {
    currentcounter .tl_set:N = \l__zrefclever_current_counter_tl ,
    currentcounter .default:n = \@currentcounter ,
    currentcounter .initial:n = \@currentcounter ,
  }
\bool_new:N \l__zrefclever_labelhook_bool
\keys_define:nn { zref-clever/label }
  {
    labelhook .bool_set:N = \l__zrefclever_labelhook_bool ,
    labelhook .initial:n = true ,
    labelhook .default:n = true ,
  }
\AddToHookWithArguments { label }
  {
    \bool_if:NT \l__zrefclever_labelhook_bool
      { \zref@wrapper@babel \zref@label {#1} }
  }
\bool_new:N \g__zrefclever_nocompat_bool
\seq_new:N \g__zrefclever_nocompat_modules_seq
\keys_define:nn { zref-clever/reference }
  {
    nocompat .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \bool_gset_true:N \g__zrefclever_nocompat_bool }
          {
            \clist_map_inline:nn {#1}
              {
                \seq_if_in:NnF \g__zrefclever_nocompat_modules_seq {##1}
                  {
                    \seq_gput_right:Nn
                      \g__zrefclever_nocompat_modules_seq {##1}
                  }
              }
          }
      } ,
  }
\AddToHook { begindocument }
  {
    \keys_define:nn { zref-clever/reference }
      {
        nocompat .code:n =
          {
            \msg_warning:nnn { zref-clever }
              { option-preamble-only } { nocompat }
          }
      }
  }
\AtEndOfPackage
  {
    \AddToHook { begindocument }
      {
        \seq_map_inline:Nn \g__zrefclever_nocompat_modules_seq
          { \msg_warning:nnn { zref-clever } { unknown-compat-module } {#1} }
      }
  }
\cs_new_protected:Npn \__zrefclever_compat_module:nn #1#2
  {
    \AddToHook { begindocument }
      {
        \bool_if:NF \g__zrefclever_nocompat_bool
          { \seq_if_in:NnF \g__zrefclever_nocompat_modules_seq {#1} {#2} }
        \seq_gremove_all:Nn \g__zrefclever_nocompat_modules_seq {#1}
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_reference_seq
  {
    \keys_define:nn { zref-clever/reference }
      {
        #1 .default:o = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              {
                \__zrefclever_opt_tl_unset:c
                  { \__zrefclever_opt_varname_general:nn {#1} { tl } }
              }
              {
                \__zrefclever_opt_tl_set:cn
                  { \__zrefclever_opt_varname_general:nn {#1} { tl } }
                  {##1}
              }
          } ,
      }
  }
\keys_define:nn { zref-clever/reference }
  {
    refpre .code:n =
      {
        % NOTE Option deprecated in 2022-01-10 for v0.1.2-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { refpre } { refbounds }
      } ,
    refpos .code:n =
      {
        % NOTE Option deprecated in 2022-01-10 for v0.1.2-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { refpos } { refbounds }
      } ,
    preref .code:n =
      {
        % NOTE Option deprecated in 2022-01-14 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { preref } { refbounds }
      } ,
    postref .code:n =
      {
        % NOTE Option deprecated in 2022-01-14 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { postref } { refbounds }
      } ,
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_seq_refbounds_seq
  {
    \keys_define:nn { zref-clever/reference }
      {
        #1 .default:o = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              {
                \__zrefclever_opt_seq_unset:c
                  { \__zrefclever_opt_varname_general:nn {#1} { seq } }
              }
              {
                \seq_clear:N \l__zrefclever_tmpa_seq
                \__zrefclever_opt_seq_set_clist_split:Nn
                  \l__zrefclever_tmpa_seq {##1}
                \bool_lazy_or:nnTF
                  { \tl_if_empty_p:n {##1} }
                  {
                    \int_compare_p:nNn
                      { \seq_count:N \l__zrefclever_tmpa_seq } = { 4 }
                  }
                  {
                    \__zrefclever_opt_seq_set_eq:cN
                      { \__zrefclever_opt_varname_general:nn {#1} { seq } }
                      \l__zrefclever_tmpa_seq
                  }
                  {
                    \msg_warning:nnee { zref-clever }
                      { refbounds-must-be-four }
                      {#1} { \seq_count:N \l__zrefclever_tmpa_seq }
                  }
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_bool_maybe_type_specific_seq
  {
    \keys_define:nn { zref-clever/reference }
      {
        #1 .choice: ,
        #1 / true .code:n =
          {
            \__zrefclever_opt_bool_set_true:c
              { \__zrefclever_opt_varname_general:nn {#1} { bool } }
          } ,
        #1 / false .code:n =
          {
            \__zrefclever_opt_bool_set_false:c
              { \__zrefclever_opt_varname_general:nn {#1} { bool } }
          } ,
        #1 / unset .code:n =
          {
            \__zrefclever_opt_bool_unset:c
              { \__zrefclever_opt_varname_general:nn {#1} { bool } }
          } ,
        #1 .default:n = true ,
        no #1 .meta:n = { #1 = false } ,
        no #1 .value_forbidden:n = true ,
      }
  }
\keys_define:nn { zref-clever }
  {
    zcsetup .inherit:n =
      {
        zref-clever/label ,
        zref-clever/reference ,
      }
  }
\bool_lazy_and:nnT
  { \tl_if_exist_p:c { opt@ zref-clever.sty } }
  { ! \tl_if_empty_p:c { opt@ zref-clever.sty } }
  { \msg_warning:nn { zref-clever } { load-time-options } }
\NewDocumentCommand \zcsetup { m }
  { \__zrefclever_zcsetup:n {#1} }
\cs_new_protected:Npn \__zrefclever_zcsetup:n #1
  { \keys_set:nn { zref-clever/zcsetup } {#1} }
\cs_generate_variant:Nn \__zrefclever_zcsetup:n { e }
\NewDocumentCommand \zcRefTypeSetup { m m }
  {
    \tl_set:Nn \l__zrefclever_setup_type_tl {#1}
    \keys_set:nn { zref-clever/typesetup } {#2}
    \tl_clear:N \l__zrefclever_setup_type_tl
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_not_type_specific_seq
  {
    \keys_define:nn { zref-clever/typesetup }
      {
        #1 .code:n =
          {
            \msg_warning:nnn { zref-clever }
              { option-not-type-specific } {#1}
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_typesetup_seq
  {
    \keys_define:nn { zref-clever/typesetup }
      {
        #1 .default:o = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              {
                \__zrefclever_opt_tl_unset:c
                  {
                    \__zrefclever_opt_varname_type:enn
                      { \l__zrefclever_setup_type_tl } {#1} { tl }
                  }
              }
              {
                \__zrefclever_opt_tl_set:cn
                  {
                    \__zrefclever_opt_varname_type:enn
                      { \l__zrefclever_setup_type_tl } {#1} { tl }
                  }
                  {##1}
              }
          } ,
      }
  }
\keys_define:nn { zref-clever/typesetup }
  {
    endrange .code:n =
      {
        \str_case:nnF {#1}
          {
            { ref }
            {
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangefunc } { tl }
                }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangeprop } { tl }
                }
            }
            { stripprefix }
            {
              \__zrefclever_opt_tl_set:cn
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangefunc } { tl }
                }
                { __zrefclever_get_endrange_stripprefix }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangeprop } { tl }
                }
            }
            { pagecomp }
            {
              \__zrefclever_opt_tl_set:cn
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangefunc } { tl }
                }
                { __zrefclever_get_endrange_pagecomp }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangeprop } { tl }
                }
            }
            { pagecomp2 }
            {
              \__zrefclever_opt_tl_set:cn
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangefunc } { tl }
                }
                { __zrefclever_get_endrange_pagecomptwo }
              \__zrefclever_opt_tl_clear:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangeprop } { tl }
                }
            }
            { unset }
            {
              \__zrefclever_opt_tl_unset:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangefunc } { tl }
                }
              \__zrefclever_opt_tl_unset:c
                {
                  \__zrefclever_opt_varname_type:enn
                    { \l__zrefclever_setup_type_tl } { endrangeprop } { tl }
                }
            }
          }
          {
            \tl_if_empty:nTF {#1}
              {
                \msg_warning:nnn { zref-clever }
                  { endrange-property-undefined } {#1}
              }
              {
                \zref@ifpropundefined {#1}
                  {
                    \msg_warning:nnn { zref-clever }
                      { endrange-property-undefined } {#1}
                  }
                  {
                    \__zrefclever_opt_tl_set:cn
                      {
                        \__zrefclever_opt_varname_type:enn
                          { \l__zrefclever_setup_type_tl }
                          { endrangefunc } { tl }
                      }
                      { __zrefclever_get_endrange_property }
                    \__zrefclever_opt_tl_set:cn
                      {
                        \__zrefclever_opt_varname_type:enn
                          { \l__zrefclever_setup_type_tl }
                          { endrangeprop } { tl }
                      }
                      {#1}
                  }
              }
          }
      } ,
    endrange .value_required:n = true ,
  }
\keys_define:nn { zref-clever/typesetup }
  {
    refpre .code:n =
      {
        % NOTE Option deprecated in 2022-01-10 for v0.1.2-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { refpre } { refbounds }
      } ,
    refpos .code:n =
      {
        % NOTE Option deprecated in 2022-01-10 for v0.1.2-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { refpos } { refbounds }
      } ,
    preref .code:n =
      {
        % NOTE Option deprecated in 2022-01-14 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { preref } { refbounds }
      } ,
    postref .code:n =
      {
        % NOTE Option deprecated in 2022-01-14 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { postref } { refbounds }
      } ,
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_seq_refbounds_seq
  {
    \keys_define:nn { zref-clever/typesetup }
      {
        #1 .default:o = \c_novalue_tl ,
        #1 .code:n =
          {
            \tl_if_novalue:nTF {##1}
              {
                \__zrefclever_opt_seq_unset:c
                  {
                    \__zrefclever_opt_varname_type:enn
                      { \l__zrefclever_setup_type_tl } {#1} { seq }
                  }
              }
              {
                \seq_clear:N \l__zrefclever_tmpa_seq
                \__zrefclever_opt_seq_set_clist_split:Nn
                  \l__zrefclever_tmpa_seq {##1}
                \bool_lazy_or:nnTF
                  { \tl_if_empty_p:n {##1} }
                  {
                    \int_compare_p:nNn
                      { \seq_count:N \l__zrefclever_tmpa_seq } = { 4 }
                  }
                  {
                    \__zrefclever_opt_seq_set_eq:cN
                      {
                        \__zrefclever_opt_varname_type:enn
                          { \l__zrefclever_setup_type_tl } {#1} { seq }
                      }
                      \l__zrefclever_tmpa_seq
                  }
                  {
                    \msg_warning:nnee { zref-clever }
                      { refbounds-must-be-four }
                      {#1} { \seq_count:N \l__zrefclever_tmpa_seq }
                  }
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_bool_maybe_type_specific_seq
  {
    \keys_define:nn { zref-clever/typesetup }
      {
        #1 .choice: ,
        #1 / true .code:n =
          {
            \__zrefclever_opt_bool_set_true:c
              {
                \__zrefclever_opt_varname_type:enn
                  { \l__zrefclever_setup_type_tl }
                  {#1} { bool }
              }
          } ,
        #1 / false .code:n =
          {
            \__zrefclever_opt_bool_set_false:c
              {
                \__zrefclever_opt_varname_type:enn
                  { \l__zrefclever_setup_type_tl }
                  {#1} { bool }
              }
          } ,
        #1 / unset .code:n =
          {
            \__zrefclever_opt_bool_unset:c
              {
                \__zrefclever_opt_varname_type:enn
                  { \l__zrefclever_setup_type_tl }
                  {#1} { bool }
              }
          } ,
        #1 .default:n = true ,
        no #1 .meta:n = { #1 = false } ,
        no #1 .value_forbidden:n = true ,
      }
  }
\NewDocumentCommand \zcLanguageSetup { m m }
  {
    \group_begin:
      \__zrefclever_language_if_declared:nTF {#1}
        {
          \tl_clear:N \l__zrefclever_setup_type_tl
          \tl_set:Nn \l__zrefclever_setup_language_tl {#1}
          \__zrefclever_opt_seq_get:cNF
            {
              \__zrefclever_opt_varname_language:nnn
                {#1} { variants } { seq }
            }
            \l__zrefclever_lang_variants_seq
            { \seq_clear:N \l__zrefclever_lang_variants_seq }
          \seq_if_empty:NTF \l__zrefclever_lang_variants_seq
            { \tl_clear:N \l__zrefclever_lang_variant_tl }
            {
              \seq_get_left:NN \l__zrefclever_lang_variants_seq
                \l__zrefclever_lang_variant_tl
            }
          \__zrefclever_opt_seq_get:cNF
            {
              \__zrefclever_opt_varname_language:nnn
                {#1} { gender } { seq }
            }
            \l__zrefclever_lang_gender_seq
            { \seq_clear:N \l__zrefclever_lang_gender_seq }
          \keys_set:nn { zref-clever/langsetup } {#2}
        }
        { \msg_warning:nnn { zref-clever } { unknown-language-setup } {#1} }
    \group_end:
  }
\@onlypreamble \zcLanguageSetup
\keys_define:nn { zref-clever/langsetup }
  {
    type .code:n =
      {
        \tl_if_empty:nTF {#1}
          { \tl_clear:N \l__zrefclever_setup_type_tl }
          { \tl_set:Nn \l__zrefclever_setup_type_tl {#1} }
      } ,
    variant .code:n =
      {
        \seq_if_empty:NTF \l__zrefclever_lang_variants_seq
          {
            \msg_warning:nnee { zref-clever } { language-no-variants-setup }
              { \l__zrefclever_setup_language_tl } {#1}
          }
          {
            \seq_if_in:NnTF \l__zrefclever_lang_variants_seq {#1}
              { \tl_set:Nn \l__zrefclever_lang_variant_tl {#1} }
              {
                \msg_warning:nnee { zref-clever } { unknown-variant }
                  {#1} { \l__zrefclever_setup_language_tl }
                \seq_get_left:NN \l__zrefclever_lang_variants_seq
                  \l__zrefclever_lang_variant_tl
              }
          }
      } ,
    variant .value_required:n = true ,
    % NOTE Option deprecated in 2024-11-24 for v0.5.0.
    case .meta:n = { variant = {#1} } ,
    gender .value_required:n = true ,
    gender .code:n =
      {
        \seq_if_empty:NTF \l__zrefclever_lang_gender_seq
          {
            \msg_warning:nneee { zref-clever } { language-no-gender }
              { \l__zrefclever_setup_language_tl } { gender } {#1}
          }
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \msg_warning:nnn { zref-clever }
                  { option-only-type-specific } { gender }
              }
              {
                \seq_clear:N \l__zrefclever_tmpa_seq
                \clist_map_inline:nn {#1}
                  {
                    \seq_if_in:NnTF \l__zrefclever_lang_gender_seq {##1}
                      { \seq_put_right:Nn \l__zrefclever_tmpa_seq {##1} }
                      {
                        \msg_warning:nnee { zref-clever }
                          { gender-not-declared }
                          { \l__zrefclever_setup_language_tl } {##1}
                      }
                  }
                \__zrefclever_opt_seq_gset_eq:cN
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      { gender }
                      { seq }
                  }
                  \l__zrefclever_tmpa_seq
              }
          }
      } ,
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_not_type_specific_seq
  {
    \keys_define:nn { zref-clever/langsetup }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_tl_gset:cn
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl } {#1} { tl }
                  }
                  {##1}
              }
              {
                \msg_warning:nnn { zref-clever }
                  { option-not-type-specific } {#1}
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_maybe_type_specific_seq
  {
    \keys_define:nn { zref-clever/langsetup }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_tl_gset:cn
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl } {#1} { tl }
                  }
                  {##1}
              }
              {
                \__zrefclever_opt_tl_gset:cn
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      {#1} { tl }
                  }
                  {##1}
              }
          } ,
      }
  }
\keys_define:nn { zref-clever/langsetup }
  {
    endrange .value_required:n = true ,
    endrange .code:n =
      {
        \str_case:nnF {#1}
          {
            { ref }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
            { stripprefix }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gset:cn
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_stripprefix }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gset:cn
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_stripprefix }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
            { pagecomp }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gset:cn
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomp }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gset:cn
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomp }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
            { pagecomp2 }
            {
              \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                {
                  \__zrefclever_opt_tl_gset:cn
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomptwo }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_default:enn
                        { \l__zrefclever_setup_language_tl }
                        { endrangeprop } { tl }
                    }
                }
                {
                  \__zrefclever_opt_tl_gset:cn
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangefunc } { tl }
                    }
                    { __zrefclever_get_endrange_pagecomptwo }
                  \__zrefclever_opt_tl_gclear:c
                    {
                      \__zrefclever_opt_varname_lang_type:eenn
                        { \l__zrefclever_setup_language_tl }
                        { \l__zrefclever_setup_type_tl }
                        { endrangeprop } { tl }
                    }
                }
            }
          }
          {
            \tl_if_empty:nTF {#1}
              {
                \msg_warning:nnn { zref-clever }
                  { endrange-property-undefined } {#1}
              }
              {
                \zref@ifpropundefined {#1}
                  {
                    \msg_warning:nnn { zref-clever }
                      { endrange-property-undefined } {#1}
                  }
                  {
                    \tl_if_empty:NTF \l__zrefclever_setup_type_tl
                      {
                        \__zrefclever_opt_tl_gset:cn
                          {
                            \__zrefclever_opt_varname_lang_default:enn
                              { \l__zrefclever_setup_language_tl }
                              { endrangefunc } { tl }
                          }
                          { __zrefclever_get_endrange_property }
                        \__zrefclever_opt_tl_gset:cn
                          {
                            \__zrefclever_opt_varname_lang_default:enn
                              { \l__zrefclever_setup_language_tl }
                              { endrangeprop } { tl }
                          }
                          {#1}
                      }
                      {
                        \__zrefclever_opt_tl_gset:cn
                          {
                            \__zrefclever_opt_varname_lang_type:eenn
                              { \l__zrefclever_setup_language_tl }
                              { \l__zrefclever_setup_type_tl }
                              { endrangefunc } { tl }
                          }
                          { __zrefclever_get_endrange_property }
                        \__zrefclever_opt_tl_gset:cn
                          {
                            \__zrefclever_opt_varname_lang_type:eenn
                              { \l__zrefclever_setup_language_tl }
                              { \l__zrefclever_setup_type_tl }
                              { endrangeprop } { tl }
                          }
                          {#1}
                      }
                  }
              }
          }
      } ,
  }
\keys_define:nn { zref-clever/langsetup }
  {
    refpre .code:n =
      {
        % NOTE Option deprecated in 2022-01-10 for v0.1.2-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { refpre } { refbounds }
      } ,
    refpos .code:n =
      {
        % NOTE Option deprecated in 2022-01-10 for v0.1.2-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { refpos } { refbounds }
      } ,
    preref .code:n =
      {
        % NOTE Option deprecated in 2022-01-14 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { preref } { refbounds }
      } ,
    postref .code:n =
      {
        % NOTE Option deprecated in 2022-01-14 for v0.2.0-alpha.
        \msg_warning:nnnn { zref-clever }{ option-deprecated }
          { postref } { refbounds }
      } ,
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_tl_type_names_seq
  {
    \keys_define:nn { zref-clever/langsetup }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \msg_warning:nnn { zref-clever }
                  { option-only-type-specific } {#1}
              }
              {
                \tl_if_empty:NTF \l__zrefclever_lang_variant_tl
                  {
                    \__zrefclever_opt_tl_gset:cn
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          {#1} { tl }
                      }
                      {##1}
                  }
                  {
                    \__zrefclever_opt_tl_gset:cn
                      {
                        \__zrefclever_opt_varname_lang_type:eeen
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl }
                          { \l__zrefclever_lang_variant_tl - #1 }
                          { tl }
                      }
                      {##1}
                  }
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_seq_refbounds_seq
  {
    \keys_define:nn { zref-clever/langsetup }
      {
        #1 .value_required:n = true ,
        #1 .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \seq_gclear:N \g__zrefclever_tmpa_seq
                \__zrefclever_opt_seq_gset_clist_split:Nn
                  \g__zrefclever_tmpa_seq {##1}
                \bool_lazy_or:nnTF
                  { \tl_if_empty_p:n {##1} }
                  {
                    \int_compare_p:nNn
                      { \seq_count:N \g__zrefclever_tmpa_seq } = { 4 }
                  }
                  {
                    \__zrefclever_opt_seq_gset_eq:cN
                      {
                        \__zrefclever_opt_varname_lang_default:enn
                          { \l__zrefclever_setup_language_tl }
                          {#1} { seq }
                      }
                      \g__zrefclever_tmpa_seq
                  }
                  {
                    \msg_warning:nnee { zref-clever }
                      { refbounds-must-be-four }
                      {#1} { \seq_count:N \g__zrefclever_tmpa_seq }
                  }
              }
              {
                \seq_gclear:N \g__zrefclever_tmpa_seq
                \__zrefclever_opt_seq_gset_clist_split:Nn
                  \g__zrefclever_tmpa_seq {##1}
                \bool_lazy_or:nnTF
                  { \tl_if_empty_p:n {##1} }
                  {
                    \int_compare_p:nNn
                      { \seq_count:N \g__zrefclever_tmpa_seq } = { 4 }
                  }
                  {
                    \__zrefclever_opt_seq_gset_eq:cN
                      {
                        \__zrefclever_opt_varname_lang_type:eenn
                          { \l__zrefclever_setup_language_tl }
                          { \l__zrefclever_setup_type_tl } {#1} { seq }
                      }
                      \g__zrefclever_tmpa_seq
                  }
                  {
                    \msg_warning:nnee { zref-clever }
                      { refbounds-must-be-four }
                      {#1} { \seq_count:N \g__zrefclever_tmpa_seq }
                  }
              }
          } ,
      }
  }
\seq_map_inline:Nn
  \g__zrefclever_rf_opts_bool_maybe_type_specific_seq
  {
    \keys_define:nn { zref-clever/langsetup }
      {
        #1 .choice: ,
        #1 / true .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_bool_gset_true:c
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl }
                      {#1} { bool }
                  }
              }
              {
                \__zrefclever_opt_bool_gset_true:c
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      {#1} { bool }
                  }
              }
          } ,
        #1 / false .code:n =
          {
            \tl_if_empty:NTF \l__zrefclever_setup_type_tl
              {
                \__zrefclever_opt_bool_gset_false:c
                  {
                    \__zrefclever_opt_varname_lang_default:enn
                      { \l__zrefclever_setup_language_tl }
                      {#1} { bool }
                  }
              }
              {
                \__zrefclever_opt_bool_gset_false:c
                  {
                    \__zrefclever_opt_varname_lang_type:eenn
                      { \l__zrefclever_setup_language_tl }
                      { \l__zrefclever_setup_type_tl }
                      {#1} { bool }
                  }
              }
          } ,
        #1 .default:n = true ,
        no #1 .meta:n = { #1 = false } ,
        no #1 .value_forbidden:n = true ,
      }
  }
\NewDocumentCommand \zcref { s O { } m }
  { \zref@wrapper@babel \__zrefclever_zcref:nnn {#3} {#1} {#2} }
\cs_new_protected:Npn \__zrefclever_zcref:nnn #1#2#3
  {
    \group_begin:
      \keys_set:nn { zref-clever/reference } {#3}
      \seq_set_from_clist:Nn \l__zrefclever_zcref_labels_seq {#1}
      \bool_set:Nn \l__zrefclever_link_star_bool {#2}
      \__zrefclever_provide_langfile:e { \l__zrefclever_ref_language_tl }
      \__zrefclever_process_language_settings:
      \bool_lazy_and:nnT
        { \l__zrefclever_zrefcheck_available_bool }
        { \l__zrefclever_zcref_with_check_bool }
        { \zrefcheck_zcref_beg_label: }
      \bool_lazy_or:nnT
        { \l__zrefclever_typeset_sort_bool }
        { \l__zrefclever_typeset_range_bool }
        { \__zrefclever_sort_labels: }
      \group_begin:
        \l__zrefclever_ref_typeset_font_tl
        \__zrefclever_typeset_refs:
      \group_end:
      \tl_if_empty:NF \l__zrefclever_zcref_note_tl
        {
          \__zrefclever_get_rf_opt_tl:neeN { notesep }
            { \l__zrefclever_label_type_a_tl }
            { \l__zrefclever_ref_language_tl }
            \l__zrefclever_tmpa_tl
          \l__zrefclever_tmpa_tl
          \l__zrefclever_zcref_note_tl
        }
      \bool_lazy_and:nnT
        { \l__zrefclever_zrefcheck_available_bool }
        { \l__zrefclever_zcref_with_check_bool }
        {
          \zrefcheck_zcref_end_label_maybe:
          \zrefcheck_zcref_run_checks_on_labels:n
            { \l__zrefclever_zcref_labels_seq }
        }
      \bool_if:NT \l__zrefclever_mathtools_loaded_bool
        {
          \__zrefclever_mathtools_showonlyrefs:n
            { \l__zrefclever_zcref_labels_seq }
        }
    \group_end:
  }
\seq_new:N \l__zrefclever_zcref_labels_seq
\bool_new:N \l__zrefclever_link_star_bool
\NewDocumentCommand \zcpageref { s O { } m }
  {
    \group_begin:
      \IfBooleanT {#1}
        { \bool_set_false:N \l__zrefclever_hyperlink_bool }
      \zcref [#2, ref = page] {#3}
    \group_end:
  }
\tl_new:N \l__zrefclever_label_type_a_tl
\tl_new:N \l__zrefclever_label_type_b_tl
\tl_new:N \l__zrefclever_label_enclval_a_tl
\tl_new:N \l__zrefclever_label_enclval_b_tl
\tl_new:N \l__zrefclever_label_extdoc_a_tl
\tl_new:N \l__zrefclever_label_extdoc_b_tl
\bool_new:N \l__zrefclever_sort_decided_bool
\int_new:N \l__zrefclever_sort_prior_a_int
\int_new:N \l__zrefclever_sort_prior_b_int
\seq_new:N \l__zrefclever_label_types_seq
\cs_new_protected:Npn \__zrefclever_sort_labels:
  {
    \seq_clear:N \l__zrefclever_label_types_seq
    \tl_if_eq:NnF \l__zrefclever_ref_property_tl { page }
      {
        \seq_map_function:NN \l__zrefclever_zcref_labels_seq
          \__zrefclever_label_type_put_new_right:n
      }
    \seq_sort:Nn \l__zrefclever_zcref_labels_seq
      {
        \zref@ifrefundefined {##1}
          {
            \zref@ifrefundefined {##2}
              {
                % Neither label is defined.
                \sort_return_same:
              }
              {
                % The second label is defined, but the first isn't, leave the
                % undefined first (to be more visible).
                \sort_return_same:
              }
          }
          {
            \zref@ifrefundefined {##2}
              {
                % The first label is defined, but the second isn't, bring the
                % second forward.
                \sort_return_swapped:
              }
              {
                % The interesting case: both labels are defined.  References
                % to the "default" property or to the "page" are quite
                % different with regard to sorting, so we branch them here to
                % specialized functions.
                \tl_if_eq:NnTF \l__zrefclever_ref_property_tl { page }
                  { \__zrefclever_sort_page:nn {##1} {##2} }
                  { \__zrefclever_sort_default:nn {##1} {##2} }
              }
          }
      }
  }
\cs_new_protected:Npn \__zrefclever_label_type_put_new_right:n #1
  {
    \__zrefclever_extract_default:Nnnn
      \l__zrefclever_label_type_a_tl {#1} { zc@type } { }
    \seq_if_in:NVF \l__zrefclever_label_types_seq
      \l__zrefclever_label_type_a_tl
      {
        \seq_put_right:NV \l__zrefclever_label_types_seq
          \l__zrefclever_label_type_a_tl
      }
  }
\cs_new_protected:Npn \__zrefclever_sort_default:nn #1#2
  {
    \__zrefclever_extract_default:Nnnn
      \l__zrefclever_label_type_a_tl {#1} { zc@type } { zc@missingtype }
    \__zrefclever_extract_default:Nnnn
      \l__zrefclever_label_type_b_tl {#2} { zc@type } { zc@missingtype }
    \tl_if_eq:NNTF
      \l__zrefclever_label_type_a_tl
      \l__zrefclever_label_type_b_tl
      { \__zrefclever_sort_default_same_type:nn {#1} {#2} }
      { \__zrefclever_sort_default_different_types:nn {#1} {#2} }
  }
\cs_new_protected:Npn \__zrefclever_sort_default_same_type:nn #1#2
  {
    \__zrefclever_extract_default:Nnnn \l__zrefclever_label_enclval_a_tl
      {#1} { zc@enclval } { }
    \tl_reverse:N \l__zrefclever_label_enclval_a_tl
    \__zrefclever_extract_default:Nnnn \l__zrefclever_label_enclval_b_tl
      {#2} { zc@enclval } { }
    \tl_reverse:N \l__zrefclever_label_enclval_b_tl
    \__zrefclever_extract_default:Nnnn \l__zrefclever_label_extdoc_a_tl
      {#1} { externaldocument } { }
    \__zrefclever_extract_default:Nnnn \l__zrefclever_label_extdoc_b_tl
      {#2} { externaldocument } { }
    \bool_set_false:N \l__zrefclever_sort_decided_bool
    % First we check if there's any "external document" difference (coming
    % from `zref-xr') and, if so, sort based on that.
    \tl_if_eq:NNF
      \l__zrefclever_label_extdoc_a_tl
      \l__zrefclever_label_extdoc_b_tl
      {
        \bool_if:nTF
          {
            \tl_if_empty_p:V \l__zrefclever_label_extdoc_a_tl &&
            ! \tl_if_empty_p:V \l__zrefclever_label_extdoc_b_tl
          }
          {
            \bool_set_true:N \l__zrefclever_sort_decided_bool
            \sort_return_same:
          }
          {
            \bool_if:nTF
              {
                ! \tl_if_empty_p:V \l__zrefclever_label_extdoc_a_tl &&
                \tl_if_empty_p:V \l__zrefclever_label_extdoc_b_tl
              }
              {
                \bool_set_true:N \l__zrefclever_sort_decided_bool
                \sort_return_swapped:
              }
              {
                \bool_set_true:N \l__zrefclever_sort_decided_bool
                % Two different "external documents": last resort, sort by the
                % document name itself.
                \str_compare:eNeTF
                  { \l__zrefclever_label_extdoc_b_tl } <
                  { \l__zrefclever_label_extdoc_a_tl }
                  { \sort_return_swapped: }
                  { \sort_return_same:    }
              }
          }
      }
    \bool_until_do:Nn \l__zrefclever_sort_decided_bool
      {
        \bool_if:nTF
          {
            % Both are empty: neither label has any (further) "enclosing
            % counters" (left).
            \tl_if_empty_p:V \l__zrefclever_label_enclval_a_tl &&
            \tl_if_empty_p:V \l__zrefclever_label_enclval_b_tl
          }
          {
            \bool_set_true:N \l__zrefclever_sort_decided_bool
            \int_compare:nNnTF
              { \__zrefclever_extract:nnn {#1} { zc@cntval } { -1 } }
                >
              { \__zrefclever_extract:nnn {#2} { zc@cntval } { -1 } }
              { \sort_return_swapped: }
              { \sort_return_same:    }
          }
          {
            \bool_if:nTF
              {
                % `a' is empty (and `b' is not): `b' may be nested in `a'.
                \tl_if_empty_p:V \l__zrefclever_label_enclval_a_tl
              }
              {
                \bool_set_true:N \l__zrefclever_sort_decided_bool
                \int_compare:nNnTF
                  { \__zrefclever_extract:nnn {#1} { zc@cntval } { -1 } }
                    >
                  { \tl_head:N \l__zrefclever_label_enclval_b_tl }
                  { \sort_return_swapped: }
                  { \sort_return_same:    }
              }
              {
                \bool_if:nTF
                  {
                    % `b' is empty (and `a' is not): `a' may be nested in `b'.
                    \tl_if_empty_p:V \l__zrefclever_label_enclval_b_tl
                  }
                  {
                    \bool_set_true:N \l__zrefclever_sort_decided_bool
                    \int_compare:nNnTF
                      { \tl_head:N \l__zrefclever_label_enclval_a_tl }
                        <
                      { \__zrefclever_extract:nnn {#2} { zc@cntval } { -1 } }
                      { \sort_return_same:    }
                      { \sort_return_swapped: }
                  }
                  {
                    % Neither is empty: we can compare the values of the
                    % current enclosing counter in the loop, if they are
                    % equal, we are still in the loop, if they are not, a
                    % sorting decision can be made directly.
                    \int_compare:nNnTF
                      { \tl_head:N \l__zrefclever_label_enclval_a_tl }
                        =
                      { \tl_head:N \l__zrefclever_label_enclval_b_tl }
                      {
                        \tl_set:Ne \l__zrefclever_label_enclval_a_tl
                          { \tl_tail:N \l__zrefclever_label_enclval_a_tl }
                        \tl_set:Ne \l__zrefclever_label_enclval_b_tl
                          { \tl_tail:N \l__zrefclever_label_enclval_b_tl }
                      }
                      {
                        \bool_set_true:N \l__zrefclever_sort_decided_bool
                        \int_compare:nNnTF
                          { \tl_head:N \l__zrefclever_label_enclval_a_tl }
                            >
                          { \tl_head:N \l__zrefclever_label_enclval_b_tl }
                          { \sort_return_swapped: }
                          { \sort_return_same:    }
                      }
                  }
              }
          }
      }
  }
\cs_new_protected:Npn \__zrefclever_sort_default_different_types:nn #1#2
  {
    \int_zero:N \l__zrefclever_sort_prior_a_int
    \int_zero:N \l__zrefclever_sort_prior_b_int
    \seq_map_indexed_inline:Nn \l__zrefclever_typesort_seq
      {
        \tl_if_eq:nnTF {##2} {{othertypes}}
          {
            \int_compare:nNnT { \l__zrefclever_sort_prior_a_int } = { 0 }
              { \int_set:Nn \l__zrefclever_sort_prior_a_int { - ##1 } }
            \int_compare:nNnT { \l__zrefclever_sort_prior_b_int } = { 0 }
              { \int_set:Nn \l__zrefclever_sort_prior_b_int { - ##1 } }
          }
          {
            \tl_if_eq:NnTF \l__zrefclever_label_type_a_tl {##2}
              { \int_set:Nn \l__zrefclever_sort_prior_a_int { - ##1 } }
              {
                \tl_if_eq:NnT \l__zrefclever_label_type_b_tl {##2}
                  { \int_set:Nn \l__zrefclever_sort_prior_b_int { - ##1 } }
              }
          }
      }
    \bool_if:nTF
      {
        \int_compare_p:nNn
          { \l__zrefclever_sort_prior_a_int } <
          { \l__zrefclever_sort_prior_b_int }
      }
      { \sort_return_same: }
      {
        \bool_if:nTF
          {
            \int_compare_p:nNn
              { \l__zrefclever_sort_prior_a_int } >
              { \l__zrefclever_sort_prior_b_int }
          }
          { \sort_return_swapped: }
          {
            % Sort priorities are equal: the type that occurs first in
            % `labels', as given by the user, is kept (or brought) forward.
            \seq_map_inline:Nn \l__zrefclever_label_types_seq
              {
                \tl_if_eq:NnTF \l__zrefclever_label_type_a_tl {##1}
                  { \seq_map_break:n { \sort_return_same: } }
                  {
                    \tl_if_eq:NnT \l__zrefclever_label_type_b_tl {##1}
                      { \seq_map_break:n { \sort_return_swapped: } }
                  }
              }
          }
      }
  }
\cs_new_protected:Npn \__zrefclever_sort_page:nn #1#2
  {
    \int_compare:nNnTF
      { \__zrefclever_extract:nnn {#1} { abspage } { -1 } }
        >
      { \__zrefclever_extract:nnn {#2} { abspage } { -1 } }
      { \sort_return_swapped: }
      { \sort_return_same:    }
  }
\seq_new:N \l__zrefclever_typeset_labels_seq
\bool_new:N \l__zrefclever_typeset_last_bool
\bool_new:N \l__zrefclever_last_of_type_bool
\int_new:N \l__zrefclever_type_count_int
\int_new:N \l__zrefclever_label_count_int
\int_new:N \l__zrefclever_ref_count_int
\tl_new:N \l__zrefclever_label_a_tl
\tl_new:N \l__zrefclever_label_b_tl
\tl_new:N \l__zrefclever_typeset_queue_prev_tl
\tl_new:N \l__zrefclever_typeset_queue_curr_tl
\tl_new:N \l__zrefclever_type_first_label_tl
\tl_new:N \l__zrefclever_type_first_label_type_tl
\tl_new:N \l__zrefclever_type_name_tl
\bool_new:N \l__zrefclever_name_in_link_bool
\bool_new:N \l__zrefclever_type_name_missing_bool
\tl_new:N \l__zrefclever_name_format_tl
\tl_new:N \l__zrefclever_name_format_fallback_tl
\seq_new:N \l__zrefclever_type_name_gender_seq
\int_new:N \l__zrefclever_range_count_int
\int_new:N \l__zrefclever_range_same_count_int
\tl_new:N \l__zrefclever_range_beg_label_tl
\bool_new:N \l__zrefclever_range_beg_is_first_bool
\tl_new:N \l__zrefclever_range_end_ref_tl
\bool_new:N \l__zrefclever_next_maybe_range_bool
\bool_new:N \l__zrefclever_next_is_same_bool
\tl_new:N \l__zrefclever_tpairsep_tl
\tl_new:N \l__zrefclever_tlistsep_tl
\tl_new:N \l__zrefclever_tlastsep_tl
\tl_new:N \l__zrefclever_namesep_tl
\tl_new:N \l__zrefclever_pairsep_tl
\tl_new:N \l__zrefclever_listsep_tl
\tl_new:N \l__zrefclever_lastsep_tl
\tl_new:N \l__zrefclever_rangesep_tl
\tl_new:N \l__zrefclever_namefont_tl
\tl_new:N \l__zrefclever_reffont_tl
\tl_new:N \l__zrefclever_endrangefunc_tl
\tl_new:N \l__zrefclever_endrangeprop_tl
\bool_new:N \l__zrefclever_cap_bool
\bool_new:N \l__zrefclever_abbrev_bool
\bool_new:N \l__zrefclever_rangetopair_bool
\seq_new:N \l__zrefclever_refbounds_first_seq
\seq_new:N \l__zrefclever_refbounds_first_sg_seq
\seq_new:N \l__zrefclever_refbounds_first_pb_seq
\seq_new:N \l__zrefclever_refbounds_first_rb_seq
\seq_new:N \l__zrefclever_refbounds_mid_seq
\seq_new:N \l__zrefclever_refbounds_mid_rb_seq
\seq_new:N \l__zrefclever_refbounds_mid_re_seq
\seq_new:N \l__zrefclever_refbounds_last_seq
\seq_new:N \l__zrefclever_refbounds_last_pe_seq
\seq_new:N \l__zrefclever_refbounds_last_re_seq
\seq_new:N \l__zrefclever_type_first_refbounds_seq
\bool_new:N \l__zrefclever_type_first_refbounds_set_bool
\bool_new:N \l__zrefclever_verbose_testing_bool
\cs_new_protected:Npn \__zrefclever_typeset_refs:
  {
    \seq_set_eq:NN \l__zrefclever_typeset_labels_seq
      \l__zrefclever_zcref_labels_seq
    \tl_clear:N \l__zrefclever_typeset_queue_prev_tl
    \tl_clear:N \l__zrefclever_typeset_queue_curr_tl
    \tl_clear:N \l__zrefclever_type_first_label_tl
    \tl_clear:N \l__zrefclever_type_first_label_type_tl
    \tl_clear:N \l__zrefclever_range_beg_label_tl
    \tl_clear:N \l__zrefclever_range_end_ref_tl
    \int_zero:N \l__zrefclever_label_count_int
    \int_zero:N \l__zrefclever_type_count_int
    \int_zero:N \l__zrefclever_ref_count_int
    \int_zero:N \l__zrefclever_range_count_int
    \int_zero:N \l__zrefclever_range_same_count_int
    \bool_set_false:N \l__zrefclever_range_beg_is_first_bool
    \bool_set_false:N \l__zrefclever_type_first_refbounds_set_bool
    % Get type block options (not type-specific).
    \__zrefclever_get_rf_opt_tl:neeN { tpairsep }
      { \l__zrefclever_label_type_a_tl }
      { \l__zrefclever_ref_language_tl }
      \l__zrefclever_tpairsep_tl
    \__zrefclever_get_rf_opt_tl:neeN { tlistsep }
      { \l__zrefclever_label_type_a_tl }
      { \l__zrefclever_ref_language_tl }
      \l__zrefclever_tlistsep_tl
    \__zrefclever_get_rf_opt_tl:neeN { tlastsep }
      { \l__zrefclever_label_type_a_tl }
      { \l__zrefclever_ref_language_tl }
      \l__zrefclever_tlastsep_tl
    % Process label stack.
    \bool_set_false:N \l__zrefclever_typeset_last_bool
    \bool_until_do:Nn \l__zrefclever_typeset_last_bool
      {
        \seq_pop_left:NN \l__zrefclever_typeset_labels_seq
          \l__zrefclever_label_a_tl
        \seq_if_empty:NTF \l__zrefclever_typeset_labels_seq
          {
            \tl_clear:N \l__zrefclever_label_b_tl
            \bool_set_true:N \l__zrefclever_typeset_last_bool
          }
          {
            \seq_get_left:NN \l__zrefclever_typeset_labels_seq
              \l__zrefclever_label_b_tl
          }
        \tl_if_eq:NnTF \l__zrefclever_ref_property_tl { page }
          {
            \tl_set:Nn \l__zrefclever_label_type_a_tl { page }
            \tl_set:Nn \l__zrefclever_label_type_b_tl { page }
          }
          {
            \__zrefclever_extract_default:NVnn
              \l__zrefclever_label_type_a_tl
              \l__zrefclever_label_a_tl { zc@type } { zc@missingtype }
            \__zrefclever_extract_default:NVnn
              \l__zrefclever_label_type_b_tl
              \l__zrefclever_label_b_tl { zc@type } { zc@missingtype }
          }
        % First, we establish whether the "current label" (i.e. `a') is the
        % last one of its type.  This can happen because the "next label"
        % (i.e. `b') is of a different type (or different definition status),
        % or because we are at the end of the list.
        \bool_if:NTF \l__zrefclever_typeset_last_bool
          { \bool_set_true:N \l__zrefclever_last_of_type_bool }
          {
            \zref@ifrefundefined { \l__zrefclever_label_a_tl }
              {
                \zref@ifrefundefined { \l__zrefclever_label_b_tl }
                  { \bool_set_false:N \l__zrefclever_last_of_type_bool }
                  { \bool_set_true:N \l__zrefclever_last_of_type_bool  }
              }
              {
                \zref@ifrefundefined { \l__zrefclever_label_b_tl }
                  { \bool_set_true:N \l__zrefclever_last_of_type_bool }
                  {
                    % Neither is undefined, we must check the types.
                    \tl_if_eq:NNTF
                      \l__zrefclever_label_type_a_tl
                      \l__zrefclever_label_type_b_tl
                      { \bool_set_false:N \l__zrefclever_last_of_type_bool }
                      { \bool_set_true:N \l__zrefclever_last_of_type_bool  }
                  }
              }
          }
        % Handle warnings in case of reference or type undefined.
        % Test: `zc-typeset01.lvt': "Typeset refs: warn ref undefined"
        \zref@refused { \l__zrefclever_label_a_tl }
        % Test: `zc-typeset01.lvt': "Typeset refs: warn missing type"
        \zref@ifrefundefined { \l__zrefclever_label_a_tl }
          {}
          {
            \tl_if_eq:NnT \l__zrefclever_label_type_a_tl { zc@missingtype }
              {
                \msg_warning:nne { zref-clever } { missing-type }
                  { \l__zrefclever_label_a_tl }
              }
            \zref@ifrefcontainsprop
              { \l__zrefclever_label_a_tl }
              { \l__zrefclever_ref_property_tl }
              { }
              {
                \msg_warning:nnee { zref-clever } { missing-property }
                  { \l__zrefclever_ref_property_tl }
                  { \l__zrefclever_label_a_tl }
              }
          }
        % Get possibly type-specific separators, refbounds, font and other
        % options, once per type.
        \int_compare:nNnT { \l__zrefclever_label_count_int } = { 0 }
          {
            \__zrefclever_get_rf_opt_tl:neeN { namesep }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_namesep_tl
            \__zrefclever_get_rf_opt_tl:neeN { pairsep }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_pairsep_tl
            \__zrefclever_get_rf_opt_tl:neeN { listsep }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_listsep_tl
            \__zrefclever_get_rf_opt_tl:neeN { lastsep }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_lastsep_tl
            \__zrefclever_get_rf_opt_tl:neeN { rangesep }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_rangesep_tl
            \__zrefclever_get_rf_opt_tl:neeN { namefont }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_namefont_tl
            \__zrefclever_get_rf_opt_tl:neeN { reffont }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_reffont_tl
            \__zrefclever_get_rf_opt_tl:neeN { endrangefunc }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_endrangefunc_tl
            \__zrefclever_get_rf_opt_tl:neeN { endrangeprop }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_endrangeprop_tl
            \__zrefclever_get_rf_opt_bool:nneeN { cap } { false }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_cap_bool
            \__zrefclever_get_rf_opt_bool:nneeN { abbrev } { false }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_abbrev_bool
            \__zrefclever_get_rf_opt_bool:nneeN { rangetopair } { true }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_rangetopair_bool
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-first }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_first_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-first-sg }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_first_sg_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-first-pb }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_first_pb_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-first-rb }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_first_rb_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-mid }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_mid_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-mid-rb }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_mid_rb_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-mid-re }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_mid_re_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-last }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_last_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-last-pe }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_last_pe_seq
            \__zrefclever_get_rf_opt_seq:neeN { refbounds-last-re }
              { \l__zrefclever_label_type_a_tl }
              { \l__zrefclever_ref_language_tl }
              \l__zrefclever_refbounds_last_re_seq
          }
        % Here we send this to a couple of auxiliary functions.
        \bool_if:NTF \l__zrefclever_last_of_type_bool
          % There exists no next label of the same type as the current.
          { \__zrefclever_typeset_refs_last_of_type: }
          % There exists a next label of the same type as the current.
          { \__zrefclever_typeset_refs_not_last_of_type: }
      }
  }
\cs_new_protected:Npn \__zrefclever_typeset_refs_last_of_type:
  {
    % Process the current label to the current queue.
    \int_case:nnF { \l__zrefclever_label_count_int }
      {
        % It is the last label of its type, but also the first one, and that's
        % what matters here: just store it.
        % Test: `zc-typeset01.lvt': "Last of type: single"
        { 0 }
        {
          \tl_set:NV \l__zrefclever_type_first_label_tl
            \l__zrefclever_label_a_tl
          \tl_set:NV \l__zrefclever_type_first_label_type_tl
            \l__zrefclever_label_type_a_tl
          \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
            \l__zrefclever_refbounds_first_sg_seq
          \bool_set_true:N \l__zrefclever_type_first_refbounds_set_bool
        }
        % The last is the second: we have a pair (if not repeated).
        % Test: `zc-typeset01.lvt': "Last of type: pair"
        { 1 }
        {
          \int_compare:nNnTF { \l__zrefclever_range_same_count_int } = { 1 }
            {
              \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                \l__zrefclever_refbounds_first_sg_seq
              \bool_set_true:N \l__zrefclever_type_first_refbounds_set_bool
            }
            {
              \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                {
                  \exp_not:V \l__zrefclever_pairsep_tl
                  \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                    \l__zrefclever_refbounds_last_pe_seq
                }
              \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                \l__zrefclever_refbounds_first_pb_seq
              \bool_set_true:N \l__zrefclever_type_first_refbounds_set_bool
            }
        }
      }
      % Last is third or more of its type: without repetition, we'd have the
      % last element on a list, but control for possible repetition.
      {
        \int_case:nnF { \l__zrefclever_range_count_int }
          {
            % There was no range going on.
            % Test: `zc-typeset01.lvt': "Last of type: not range"
            { 0 }
            {
              \int_compare:nNnTF { \l__zrefclever_ref_count_int } < { 2 }
                {
                  \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                    {
                      \exp_not:V \l__zrefclever_pairsep_tl
                      \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                        \l__zrefclever_refbounds_last_pe_seq
                    }
                }
                {
                  \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                    {
                      \exp_not:V \l__zrefclever_lastsep_tl
                      \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                        \l__zrefclever_refbounds_last_seq
                    }
                }
            }
            % Last in the range is also the second in it.
            % Test: `zc-typeset01.lvt': "Last of type: pair in sequence"
            { 1 }
            {
              \int_compare:nNnTF
                { \l__zrefclever_range_same_count_int } = { 1 }
                {
                  % We know `range_beg_is_first_bool' is false, since this is
                  % the second element in the range, but the third or more in
                  % the type list.
                  \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                    {
                      \exp_not:V \l__zrefclever_pairsep_tl
                      \__zrefclever_get_ref:VN
                        \l__zrefclever_range_beg_label_tl
                        \l__zrefclever_refbounds_last_pe_seq
                    }
                  \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                    \l__zrefclever_refbounds_first_pb_seq
                  \bool_set_true:N
                    \l__zrefclever_type_first_refbounds_set_bool
                }
                {
                  \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                    {
                      \exp_not:V \l__zrefclever_listsep_tl
                      \__zrefclever_get_ref:VN
                        \l__zrefclever_range_beg_label_tl
                        \l__zrefclever_refbounds_mid_seq
                      \exp_not:V \l__zrefclever_lastsep_tl
                      \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                        \l__zrefclever_refbounds_last_seq
                    }
                }
            }
          }
          % Last in the range is third or more in it.
          {
            \int_case:nnF
              {
                \l__zrefclever_range_count_int -
                \l__zrefclever_range_same_count_int
              }
              {
                % Repetition, not a range.
                % Test: `zc-typeset01.lvt': "Last of type: range to one"
                { 0 }
                {
                  % If `range_beg_is_first_bool' is true, it means it was also
                  % the first of the type, and hence its typesetting was
                  % already handled, and we just have to set refbounds.
                  \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                    {
                      \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                        \l__zrefclever_refbounds_first_sg_seq
                      \bool_set_true:N
                        \l__zrefclever_type_first_refbounds_set_bool
                    }
                    {
                      \int_compare:nNnTF
                        { \l__zrefclever_ref_count_int } < { 2 }
                        {
                          \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                            {
                              \exp_not:V \l__zrefclever_pairsep_tl
                              \__zrefclever_get_ref:VN
                                \l__zrefclever_range_beg_label_tl
                                \l__zrefclever_refbounds_last_pe_seq
                            }
                        }
                        {
                          \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                            {
                              \exp_not:V \l__zrefclever_lastsep_tl
                              \__zrefclever_get_ref:VN
                                \l__zrefclever_range_beg_label_tl
                                \l__zrefclever_refbounds_last_seq
                            }
                        }
                    }
                }
                % A `range', but with no skipped value, treat as pair if range
                % started with first of type, otherwise as list.
                % Test: `zc-typeset01.lvt': "Last of type: range to pair"
                { 1 }
                {
                  % Ditto.
                  \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                    {
                      \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                        \l__zrefclever_refbounds_first_pb_seq
                      \bool_set_true:N
                        \l__zrefclever_type_first_refbounds_set_bool
                      \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                        {
                          \exp_not:V \l__zrefclever_pairsep_tl
                          \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                            \l__zrefclever_refbounds_last_pe_seq
                        }
                    }
                    {
                      \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                        {
                          \exp_not:V \l__zrefclever_listsep_tl
                          \__zrefclever_get_ref:VN
                            \l__zrefclever_range_beg_label_tl
                            \l__zrefclever_refbounds_mid_seq
                        }
                      \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                        {
                          \exp_not:V \l__zrefclever_lastsep_tl
                          \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                            \l__zrefclever_refbounds_last_seq
                        }
                    }
                }
              }
              {
                % An actual range.
                % Test: `zc-typeset01.lvt': "Last of type: range"
                % Ditto.
                \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                  {
                    \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                      \l__zrefclever_refbounds_first_rb_seq
                    \bool_set_true:N
                      \l__zrefclever_type_first_refbounds_set_bool
                  }
                  {
                    \int_compare:nNnTF
                      { \l__zrefclever_ref_count_int } < { 2 }
                      {
                        \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                          {
                            \exp_not:V \l__zrefclever_pairsep_tl
                            \__zrefclever_get_ref:VN
                              \l__zrefclever_range_beg_label_tl
                              \l__zrefclever_refbounds_mid_rb_seq
                          }
                        \seq_set_eq:NN
                          \l__zrefclever_type_first_refbounds_seq
                          \l__zrefclever_refbounds_first_pb_seq
                        \bool_set_true:N
                          \l__zrefclever_type_first_refbounds_set_bool
                      }
                      {
                        \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                          {
                            \exp_not:V \l__zrefclever_lastsep_tl
                            \__zrefclever_get_ref:VN
                              \l__zrefclever_range_beg_label_tl
                              \l__zrefclever_refbounds_mid_rb_seq
                          }
                      }
                  }
                \bool_lazy_and:nnTF
                  { ! \tl_if_empty_p:N \l__zrefclever_endrangefunc_tl }
                  { \cs_if_exist_p:c { \l__zrefclever_endrangefunc_tl :VVN } }
                  {
                    \use:c { \l__zrefclever_endrangefunc_tl :VVN }
                      \l__zrefclever_range_beg_label_tl
                      \l__zrefclever_label_a_tl
                      \l__zrefclever_range_end_ref_tl
                    \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                      {
                        \exp_not:V \l__zrefclever_rangesep_tl
                        \__zrefclever_get_ref_endrange:VVN
                          \l__zrefclever_label_a_tl
                          \l__zrefclever_range_end_ref_tl
                          \l__zrefclever_refbounds_last_re_seq
                      }
                  }
                  {
                    \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                      {
                        \exp_not:V \l__zrefclever_rangesep_tl
                        \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                          \l__zrefclever_refbounds_last_re_seq
                      }
                  }
              }
          }
      }
    % Handle "range" option.  The idea is simple: if the queue is not empty,
    % we replace it with the end of the range (or pair).  We can still
    % retrieve the end of the range from `label_a' since we know to be
    % processing the last label of its type at this point.
    \bool_if:NT \l__zrefclever_typeset_range_bool
      {
        \tl_if_empty:NTF \l__zrefclever_typeset_queue_curr_tl
          {
            \zref@ifrefundefined { \l__zrefclever_type_first_label_tl }
              { }
              {
                \msg_warning:nne { zref-clever } { single-element-range }
                  { \l__zrefclever_type_first_label_type_tl }
              }
          }
          {
            \bool_set_false:N \l__zrefclever_next_maybe_range_bool
            \bool_if:NT \l__zrefclever_rangetopair_bool
              {
                \zref@ifrefundefined { \l__zrefclever_type_first_label_tl }
                  { }
                  {
                    \__zrefclever_labels_in_sequence:nn
                      { \l__zrefclever_type_first_label_tl }
                      { \l__zrefclever_label_a_tl }
                  }
              }
            % Test: `zc-typeset01.lvt': "Last of type: option range"
            % Test: `zc-typeset01.lvt': "Last of type: option range to pair"
            \bool_if:NTF \l__zrefclever_next_maybe_range_bool
              {
                \tl_set:Ne \l__zrefclever_typeset_queue_curr_tl
                  {
                    \exp_not:V \l__zrefclever_pairsep_tl
                    \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                      \l__zrefclever_refbounds_last_pe_seq
                  }
                \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                  \l__zrefclever_refbounds_first_pb_seq
                \bool_set_true:N \l__zrefclever_type_first_refbounds_set_bool
              }
              {
                \bool_lazy_and:nnTF
                  { ! \tl_if_empty_p:N \l__zrefclever_endrangefunc_tl }
                  { \cs_if_exist_p:c { \l__zrefclever_endrangefunc_tl :VVN } }
                  {
                    % We must get `type_first_label_tl' instead of
                    % `range_beg_label_tl' here, since it is not necessary
                    % that the first of type was actually starting a range for
                    % the `range' option to be used.
                    \use:c { \l__zrefclever_endrangefunc_tl :VVN }
                      \l__zrefclever_type_first_label_tl
                      \l__zrefclever_label_a_tl
                      \l__zrefclever_range_end_ref_tl
                    \tl_set:Ne \l__zrefclever_typeset_queue_curr_tl
                      {
                        \exp_not:V \l__zrefclever_rangesep_tl
                        \__zrefclever_get_ref_endrange:VVN
                          \l__zrefclever_label_a_tl
                          \l__zrefclever_range_end_ref_tl
                          \l__zrefclever_refbounds_last_re_seq
                      }
                  }
                  {
                    \tl_set:Ne \l__zrefclever_typeset_queue_curr_tl
                      {
                        \exp_not:V \l__zrefclever_rangesep_tl
                        \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                          \l__zrefclever_refbounds_last_re_seq
                      }
                  }
                \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                  \l__zrefclever_refbounds_first_rb_seq
                \bool_set_true:N \l__zrefclever_type_first_refbounds_set_bool
              }
          }
      }
    % If none of the special cases for the first of type refbounds have been
    % set, do it.
    \bool_if:NF \l__zrefclever_type_first_refbounds_set_bool
      {
        \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
          \l__zrefclever_refbounds_first_seq
      }
    % Now that the type block is finished, we can add the name and the first
    % ref to the queue.  Also, if "typeset" option is not "both", handle it
    % here as well.
    \__zrefclever_type_name_setup:
    \bool_if:nTF
      { \l__zrefclever_typeset_ref_bool && \l__zrefclever_typeset_name_bool }
      {
        \tl_put_left:Ne \l__zrefclever_typeset_queue_curr_tl
          { \__zrefclever_get_ref_first: }
      }
      {
        \bool_if:NTF \l__zrefclever_typeset_ref_bool
          {
            % Test: `zc-typeset01.lvt': "Last of type: option typeset ref"
            \tl_put_left:Ne \l__zrefclever_typeset_queue_curr_tl
              {
                \__zrefclever_get_ref:VN \l__zrefclever_type_first_label_tl
                  \l__zrefclever_type_first_refbounds_seq
              }
          }
          {
            \bool_if:NTF \l__zrefclever_typeset_name_bool
              {
                % Test: `zc-typeset01.lvt': "Last of type: option typeset name"
                \tl_set:Ne \l__zrefclever_typeset_queue_curr_tl
                  {
                    \bool_if:NTF \l__zrefclever_name_in_link_bool
                      {
                        \exp_not:N \group_begin:
                          \exp_not:V \l__zrefclever_namefont_tl
                          \__zrefclever_hyperlink:nnn
                            {
                              \__zrefclever_extract_url_unexp:V
                                \l__zrefclever_type_first_label_tl
                            }
                            {
                              \__zrefclever_extract_unexp:Vnn
                                \l__zrefclever_type_first_label_tl
                                { anchor } { }
                            }
                            { \exp_not:V \l__zrefclever_type_name_tl }
                        \exp_not:N \group_end:
                      }
                      {
                        \exp_not:N \group_begin:
                          \exp_not:V \l__zrefclever_namefont_tl
                          \exp_not:V \l__zrefclever_type_name_tl
                        \exp_not:N \group_end:
                      }
                  }
              }
              {
                % Logically, this case would correspond to "typeset=none", but
                % it should not occur, given that the options are set up to
                % typeset either "ref" or "name".  Still, leave here a
                % sensible fallback, equal to the behavior of "both".
                % Test: `zc-typeset01.lvt': "Last of type: option typeset none"
                \tl_put_left:Ne \l__zrefclever_typeset_queue_curr_tl
                  { \__zrefclever_get_ref_first: }
              }
          }
      }
    % Typeset the previous type block, if there is one.
    \int_compare:nNnT { \l__zrefclever_type_count_int } > { 0 }
      {
        \int_compare:nNnT { \l__zrefclever_type_count_int } > { 1 }
          { \l__zrefclever_tlistsep_tl }
        \l__zrefclever_typeset_queue_prev_tl
      }
    % Extra log for testing.
    \bool_if:NT \l__zrefclever_verbose_testing_bool
      { \tl_show:N \l__zrefclever_typeset_queue_curr_tl }
    % Wrap up loop, or prepare for next iteration.
    \bool_if:NTF \l__zrefclever_typeset_last_bool
      {
        % We are finishing, typeset the current queue.
        \int_case:nnF { \l__zrefclever_type_count_int }
          {
            % Single type.
            % Test: `zc-typeset01.lvt': "Last of type: single type"
            { 0 }
            { \l__zrefclever_typeset_queue_curr_tl }
            % Pair of types.
            % Test: `zc-typeset01.lvt': "Last of type: pair of types"
            { 1 }
            {
              \l__zrefclever_tpairsep_tl
              \l__zrefclever_typeset_queue_curr_tl
            }
          }
          {
            % Last in list of types.
            % Test: `zc-typeset01.lvt': "Last of type: list of types"
            \l__zrefclever_tlastsep_tl
            \l__zrefclever_typeset_queue_curr_tl
          }
        % And nudge in case of multitype reference.
        \bool_lazy_all:nT
          {
            { \l__zrefclever_nudge_enabled_bool }
            { \l__zrefclever_nudge_multitype_bool }
            { \int_compare_p:nNn { \l__zrefclever_type_count_int } > { 0 } }
          }
          { \msg_warning:nn { zref-clever } { nudge-multitype } }
      }
      {
        % There are further labels, set variables for next iteration.
        \tl_set_eq:NN \l__zrefclever_typeset_queue_prev_tl
          \l__zrefclever_typeset_queue_curr_tl
        \tl_clear:N \l__zrefclever_typeset_queue_curr_tl
        \tl_clear:N \l__zrefclever_type_first_label_tl
        \tl_clear:N \l__zrefclever_type_first_label_type_tl
        \tl_clear:N \l__zrefclever_range_beg_label_tl
        \tl_clear:N \l__zrefclever_range_end_ref_tl
        \int_zero:N \l__zrefclever_label_count_int
        \int_zero:N \l__zrefclever_ref_count_int
        \int_incr:N \l__zrefclever_type_count_int
        \int_zero:N \l__zrefclever_range_count_int
        \int_zero:N \l__zrefclever_range_same_count_int
        \bool_set_false:N \l__zrefclever_range_beg_is_first_bool
        \bool_set_false:N \l__zrefclever_type_first_refbounds_set_bool
      }
  }
\cs_new_protected:Npn \__zrefclever_typeset_refs_not_last_of_type:
  {
    % Signal if next label may form a range with the current one (only
    % considered if compression is enabled in the first place).
    \bool_set_false:N \l__zrefclever_next_maybe_range_bool
    \bool_set_false:N \l__zrefclever_next_is_same_bool
    \bool_if:NT \l__zrefclever_typeset_compress_bool
      {
        \zref@ifrefundefined { \l__zrefclever_label_a_tl }
          { }
          {
            \__zrefclever_labels_in_sequence:nn
              { \l__zrefclever_label_a_tl } { \l__zrefclever_label_b_tl }
          }
      }
    % Process the current label to the current queue.
    \int_compare:nNnTF { \l__zrefclever_label_count_int } = { 0 }
      {
        % Current label is the first of its type (also not the last, but it
        % doesn't matter here): just store the label.
        \tl_set:NV \l__zrefclever_type_first_label_tl
          \l__zrefclever_label_a_tl
        \tl_set:NV \l__zrefclever_type_first_label_type_tl
          \l__zrefclever_label_type_a_tl
        \int_incr:N \l__zrefclever_ref_count_int
        % If the next label may be part of a range, signal it (we deal with it
        % as the "first", and must do it there, to handle hyperlinking), but
        % also step the range counters.
        % Test: `zc-typeset01.lvt': "Not last of type: first is range"
        \bool_if:NT \l__zrefclever_next_maybe_range_bool
          {
            \bool_set_true:N \l__zrefclever_range_beg_is_first_bool
            \tl_set:NV \l__zrefclever_range_beg_label_tl
              \l__zrefclever_label_a_tl
            \tl_clear:N \l__zrefclever_range_end_ref_tl
            \int_incr:N \l__zrefclever_range_count_int
            \bool_if:NT \l__zrefclever_next_is_same_bool
              { \int_incr:N \l__zrefclever_range_same_count_int }
          }
      }
      {
        % Current label is neither the first (nor the last) of its type.
        \bool_if:NTF \l__zrefclever_next_maybe_range_bool
          {
            % Starting, or continuing a range.
            \int_compare:nNnTF
              { \l__zrefclever_range_count_int } = { 0 }
              {
                % There was no range going, we are starting one.
                \tl_set:NV \l__zrefclever_range_beg_label_tl
                  \l__zrefclever_label_a_tl
                \tl_clear:N \l__zrefclever_range_end_ref_tl
                \int_incr:N \l__zrefclever_range_count_int
                \bool_if:NT \l__zrefclever_next_is_same_bool
                  { \int_incr:N \l__zrefclever_range_same_count_int }
              }
              {
                % Second or more in the range, but not the last.
                \int_incr:N \l__zrefclever_range_count_int
                \bool_if:NT \l__zrefclever_next_is_same_bool
                  { \int_incr:N \l__zrefclever_range_same_count_int }
              }
          }
          {
            % Next element is not in sequence: there was no range, or we are
            % closing one.
            \int_case:nnF { \l__zrefclever_range_count_int }
              {
                % There was no range going on.
                % Test: `zc-typeset01.lvt': "Not last of type: no range"
                { 0 }
                {
                  \int_incr:N \l__zrefclever_ref_count_int
                  \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                    {
                      \exp_not:V \l__zrefclever_listsep_tl
                      \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                        \l__zrefclever_refbounds_mid_seq
                    }
                }
                % Last is second in the range: if `range_same_count' is also
                % `1', it's a repetition (drop it), otherwise, it's a "pair
                % within a list", treat as list.
                % Test: `zc-typeset01.lvt': "Not last of type: range pair to one"
                % Test: `zc-typeset01.lvt': "Not last of type: range pair"
                { 1 }
                {
                  \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                    {
                      \seq_set_eq:NN \l__zrefclever_type_first_refbounds_seq
                        \l__zrefclever_refbounds_first_seq
                      \bool_set_true:N
                        \l__zrefclever_type_first_refbounds_set_bool
                    }
                    {
                      \int_incr:N \l__zrefclever_ref_count_int
                      \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                        {
                          \exp_not:V \l__zrefclever_listsep_tl
                          \__zrefclever_get_ref:VN
                            \l__zrefclever_range_beg_label_tl
                            \l__zrefclever_refbounds_mid_seq
                        }
                    }
                  \int_compare:nNnF
                    { \l__zrefclever_range_same_count_int } = { 1 }
                    {
                      \int_incr:N \l__zrefclever_ref_count_int
                      \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                        {
                          \exp_not:V \l__zrefclever_listsep_tl
                          \__zrefclever_get_ref:VN
                            \l__zrefclever_label_a_tl
                            \l__zrefclever_refbounds_mid_seq
                        }
                    }
                }
              }
              {
                % Last is third or more in the range: if `range_count' and
                % `range_same_count' are the same, its a repetition (drop it),
                % if they differ by `1', its a list, if they differ by more,
                % it is a real range.
                \int_case:nnF
                  {
                    \l__zrefclever_range_count_int -
                    \l__zrefclever_range_same_count_int
                  }
                  {
                    % Test: `zc-typeset01.lvt': "Not last of type: range to one"
                    { 0 }
                    {
                      \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                        {
                          \seq_set_eq:NN
                            \l__zrefclever_type_first_refbounds_seq
                            \l__zrefclever_refbounds_first_seq
                          \bool_set_true:N
                            \l__zrefclever_type_first_refbounds_set_bool
                        }
                        {
                          \int_incr:N \l__zrefclever_ref_count_int
                          \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                            {
                              \exp_not:V \l__zrefclever_listsep_tl
                              \__zrefclever_get_ref:VN
                                \l__zrefclever_range_beg_label_tl
                                \l__zrefclever_refbounds_mid_seq
                            }
                        }
                    }
                    % Test: `zc-typeset01.lvt': "Not last of type: range to pair"
                    { 1 }
                    {
                      \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                        {
                          \seq_set_eq:NN
                            \l__zrefclever_type_first_refbounds_seq
                            \l__zrefclever_refbounds_first_seq
                          \bool_set_true:N
                            \l__zrefclever_type_first_refbounds_set_bool
                        }
                        {
                          \int_incr:N \l__zrefclever_ref_count_int
                          \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                            {
                              \exp_not:V \l__zrefclever_listsep_tl
                              \__zrefclever_get_ref:VN
                                \l__zrefclever_range_beg_label_tl
                                \l__zrefclever_refbounds_mid_seq
                            }
                        }
                      \int_incr:N \l__zrefclever_ref_count_int
                      \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                        {
                          \exp_not:V \l__zrefclever_listsep_tl
                          \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                            \l__zrefclever_refbounds_mid_seq
                        }
                    }
                  }
                  {
                    % Test: `zc-typeset01.lvt': "Not last of type: range"
                    \bool_if:NTF \l__zrefclever_range_beg_is_first_bool
                      {
                        \seq_set_eq:NN
                          \l__zrefclever_type_first_refbounds_seq
                          \l__zrefclever_refbounds_first_rb_seq
                        \bool_set_true:N
                          \l__zrefclever_type_first_refbounds_set_bool
                      }
                      {
                        \int_incr:N \l__zrefclever_ref_count_int
                        \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                          {
                            \exp_not:V \l__zrefclever_listsep_tl
                            \__zrefclever_get_ref:VN
                              \l__zrefclever_range_beg_label_tl
                              \l__zrefclever_refbounds_mid_rb_seq
                          }
                      }
                    % For the purposes of the serial comma, and thus for the
                    % distinction of `lastsep' and `pairsep', a "range" counts
                    % as one.  Since `range_beg' has already been counted
                    % (here or with the first of type), we refrain from
                    % incrementing `ref_count_int'.
                    \bool_lazy_and:nnTF
                      { ! \tl_if_empty_p:N \l__zrefclever_endrangefunc_tl }
                      { \cs_if_exist_p:c { \l__zrefclever_endrangefunc_tl :VVN } }
                      {
                        \use:c { \l__zrefclever_endrangefunc_tl :VVN }
                          \l__zrefclever_range_beg_label_tl
                          \l__zrefclever_label_a_tl
                          \l__zrefclever_range_end_ref_tl
                        \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                          {
                            \exp_not:V \l__zrefclever_rangesep_tl
                            \__zrefclever_get_ref_endrange:VVN
                              \l__zrefclever_label_a_tl
                              \l__zrefclever_range_end_ref_tl
                              \l__zrefclever_refbounds_mid_re_seq
                          }
                      }
                      {
                        \tl_put_right:Ne \l__zrefclever_typeset_queue_curr_tl
                          {
                            \exp_not:V \l__zrefclever_rangesep_tl
                            \__zrefclever_get_ref:VN \l__zrefclever_label_a_tl
                              \l__zrefclever_refbounds_mid_re_seq
                          }
                      }
                  }
              }
            % We just closed a range, reset `range_beg_is_first' in case a
            % second range for the same type occurs, in which case its
            % `range_beg' will no longer be `first'.
            \bool_set_false:N \l__zrefclever_range_beg_is_first_bool
            % Reset counters.
            \int_zero:N \l__zrefclever_range_count_int
            \int_zero:N \l__zrefclever_range_same_count_int
          }
      }
    % Step label counter for next iteration.
    \int_incr:N \l__zrefclever_label_count_int
  }
\cs_new_protected:Npn \__zrefclever_ref_default:
  { \zref@default }
\cs_new_protected:Npn \__zrefclever_name_default:
  { \zref@default }
\cs_new:Npn \__zrefclever_get_ref:nN #1#2
  {
    \zref@ifrefcontainsprop {#1} { \l__zrefclever_ref_property_tl }
      {
        \bool_if:nTF
          {
            \l__zrefclever_hyperlink_bool &&
            ! \l__zrefclever_link_star_bool
          }
          {
            \seq_item:Nn #2 { 1 }
            \__zrefclever_hyperlink:nnn
              { \__zrefclever_extract_url_unexp:n {#1} }
              { \__zrefclever_extract_unexp:nnn {#1} { anchor } { } }
              {
                \seq_item:Nn #2 { 2 }
                \exp_not:N \group_begin:
                  \exp_not:V \l__zrefclever_reffont_tl
                  \__zrefclever_extract_unexp:nvn {#1}
                    { l__zrefclever_ref_property_tl } { }
                \exp_not:N \group_end:
                \seq_item:Nn #2 { 3 }
              }
            \seq_item:Nn #2 { 4 }
          }
          {
            \seq_item:Nn #2 { 1 }
            \seq_item:Nn #2 { 2 }
            \exp_not:N \group_begin:
              \exp_not:V \l__zrefclever_reffont_tl
              \__zrefclever_extract_unexp:nvn {#1}
                { l__zrefclever_ref_property_tl } { }
            \exp_not:N \group_end:
            \seq_item:Nn #2 { 3 }
            \seq_item:Nn #2 { 4 }
          }
      }
      { \__zrefclever_ref_default: }
  }
\cs_generate_variant:Nn \__zrefclever_get_ref:nN { VN }
\cs_new:Npn \__zrefclever_get_ref_endrange:nnN #1#2#3
  {
    \str_if_eq:nnTF {#2} { zc@missingproperty }
      { \__zrefclever_ref_default: }
      {
        \bool_if:nTF
          {
            \l__zrefclever_hyperlink_bool &&
            ! \l__zrefclever_link_star_bool
          }
          {
            \seq_item:Nn #3 { 1 }
            \__zrefclever_hyperlink:nnn
              { \__zrefclever_extract_url_unexp:n {#1} }
              { \__zrefclever_extract_unexp:nnn {#1} { anchor } { } }
              {
                \seq_item:Nn #3 { 2 }
                \exp_not:N \group_begin:
                  \exp_not:V \l__zrefclever_reffont_tl
                  \exp_not:n {#2}
                \exp_not:N \group_end:
                \seq_item:Nn #3 { 3 }
              }
            \seq_item:Nn #3 { 4 }
          }
          {
            \seq_item:Nn #3 { 1 }
            \seq_item:Nn #3 { 2 }
            \exp_not:N \group_begin:
              \exp_not:V \l__zrefclever_reffont_tl
              \exp_not:n {#2}
            \exp_not:N \group_end:
            \seq_item:Nn #3 { 3 }
            \seq_item:Nn #3 { 4 }
          }
      }
  }
\cs_generate_variant:Nn \__zrefclever_get_ref_endrange:nnN { VVN }
\cs_new:Npn \__zrefclever_get_ref_first:
  {
    \zref@ifrefundefined { \l__zrefclever_type_first_label_tl }
      { \__zrefclever_ref_default: }
      {
        \bool_if:NTF \l__zrefclever_name_in_link_bool
          {
            \zref@ifrefcontainsprop
              { \l__zrefclever_type_first_label_tl }
              { \l__zrefclever_ref_property_tl }
              {
                \__zrefclever_hyperlink:nnn
                  {
                    \__zrefclever_extract_url_unexp:V
                      \l__zrefclever_type_first_label_tl
                  }
                  {
                    \__zrefclever_extract_unexp:Vnn
                      \l__zrefclever_type_first_label_tl { anchor } { }
                  }
                  {
                    \exp_not:N \group_begin:
                      \exp_not:V \l__zrefclever_namefont_tl
                      \exp_not:V \l__zrefclever_type_name_tl
                    \exp_not:N \group_end:
                    \exp_not:V \l__zrefclever_namesep_tl
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 1 }
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 2 }
                    \exp_not:N \group_begin:
                      \exp_not:V \l__zrefclever_reffont_tl
                      \__zrefclever_extract_unexp:Vvn
                        \l__zrefclever_type_first_label_tl
                        { l__zrefclever_ref_property_tl } { }
                    \exp_not:N \group_end:
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 3 }
                  }
                \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 4 }
              }
              {
                \exp_not:N \group_begin:
                  \exp_not:V \l__zrefclever_namefont_tl
                  \exp_not:V \l__zrefclever_type_name_tl
                \exp_not:N \group_end:
                \exp_not:V \l__zrefclever_namesep_tl
                \__zrefclever_ref_default:
              }
          }
          {
            \bool_if:nTF \l__zrefclever_type_name_missing_bool
              {
                \__zrefclever_name_default:
                \exp_not:V \l__zrefclever_namesep_tl
              }
              {
                \exp_not:N \group_begin:
                  \exp_not:V \l__zrefclever_namefont_tl
                  \exp_not:V \l__zrefclever_type_name_tl
                \exp_not:N \group_end:
                \tl_if_empty:NF \l__zrefclever_type_name_tl
                  { \exp_not:V \l__zrefclever_namesep_tl }
              }
            \zref@ifrefcontainsprop
              { \l__zrefclever_type_first_label_tl }
              { \l__zrefclever_ref_property_tl }
              {
                \bool_if:nTF
                  {
                    \l__zrefclever_hyperlink_bool &&
                    ! \l__zrefclever_link_star_bool
                  }
                  {
                    \seq_item:Nn
                      \l__zrefclever_type_first_refbounds_seq { 1 }
                    \__zrefclever_hyperlink:nnn
                      {
                        \__zrefclever_extract_url_unexp:V
                          \l__zrefclever_type_first_label_tl
                      }
                      {
                        \__zrefclever_extract_unexp:Vnn
                          \l__zrefclever_type_first_label_tl { anchor } { }
                      }
                      {
                        \seq_item:Nn
                          \l__zrefclever_type_first_refbounds_seq { 2 }
                        \exp_not:N \group_begin:
                          \exp_not:V \l__zrefclever_reffont_tl
                          \__zrefclever_extract_unexp:Vvn
                            \l__zrefclever_type_first_label_tl
                            { l__zrefclever_ref_property_tl } { }
                        \exp_not:N \group_end:
                        \seq_item:Nn
                          \l__zrefclever_type_first_refbounds_seq { 3 }
                      }
                    \seq_item:Nn
                      \l__zrefclever_type_first_refbounds_seq { 4 }
                  }
                  {
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 1 }
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 2 }
                    \exp_not:N \group_begin:
                      \exp_not:V \l__zrefclever_reffont_tl
                      \__zrefclever_extract_unexp:Vvn
                        \l__zrefclever_type_first_label_tl
                        { l__zrefclever_ref_property_tl } { }
                    \exp_not:N \group_end:
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 3 }
                    \seq_item:Nn \l__zrefclever_type_first_refbounds_seq { 4 }
                  }
              }
              { \__zrefclever_ref_default: }
          }
      }
  }
\cs_new_protected:Npn \__zrefclever_type_name_setup:
  {
    \bool_if:nTF
      { \l__zrefclever_typeset_ref_bool && ! \l__zrefclever_typeset_name_bool }
      {
        % `typeset=ref' / `noname' option
        % Probably redundant, since in this case the type name is not being
        % typeset.  But, for completeness sake:
        \tl_clear:N \l__zrefclever_type_name_tl
        \bool_set_false:N \l__zrefclever_name_in_link_bool
        \bool_set_true:N \l__zrefclever_type_name_missing_bool
      }
      {
        \zref@ifrefundefined { \l__zrefclever_type_first_label_tl }
          {
            \tl_clear:N \l__zrefclever_type_name_tl
            \bool_set_true:N \l__zrefclever_type_name_missing_bool
          }
          {
            \tl_if_eq:NnTF
              \l__zrefclever_type_first_label_type_tl { zc@missingtype }
              {
                \tl_clear:N \l__zrefclever_type_name_tl
                \bool_set_true:N \l__zrefclever_type_name_missing_bool
              }
              {
                % Determine whether we should use capitalization,
                % abbreviation, and plural.
                \bool_lazy_or:nnTF
                  { \l__zrefclever_cap_bool }
                  {
                    \l__zrefclever_capfirst_bool &&
                    \int_compare_p:nNn { \l__zrefclever_type_count_int } = { 0 }
                  }
                  { \tl_set:Nn \l__zrefclever_name_format_tl {Name} }
                  { \tl_set:Nn \l__zrefclever_name_format_tl {name} }
                % If the queue is empty, we have a singular, otherwise,
                % plural.
                \tl_if_empty:NTF \l__zrefclever_typeset_queue_curr_tl
                  { \tl_put_right:Nn \l__zrefclever_name_format_tl { -sg } }
                  { \tl_put_right:Nn \l__zrefclever_name_format_tl { -pl } }
                \bool_lazy_and:nnTF
                  { \l__zrefclever_abbrev_bool }
                  {
                    ! \int_compare_p:nNn
                        { \l__zrefclever_type_count_int } = { 0 } ||
                    ! \l__zrefclever_noabbrev_first_bool
                  }
                  {
                    \tl_set:NV \l__zrefclever_name_format_fallback_tl
                      \l__zrefclever_name_format_tl
                    \tl_put_right:Nn \l__zrefclever_name_format_tl { -ab }
                  }
                  { \tl_clear:N \l__zrefclever_name_format_fallback_tl }
                % Handle number and gender nudges.
                % Note that these nudges get disabled for `typeset=ref' /
                % `noname' option, but in this case they are not really
                % meaningful anyway.
                \bool_if:NT \l__zrefclever_nudge_enabled_bool
                  {
                    \bool_if:NTF \l__zrefclever_nudge_singular_bool
                      {
                        \tl_if_empty:NF \l__zrefclever_typeset_queue_curr_tl
                          {
                            \msg_warning:nne { zref-clever }
                              { nudge-plural-when-sg }
                              { \l__zrefclever_type_first_label_type_tl }
                          }
                      }
                      {
                        \bool_lazy_all:nT
                          {
                            { \l__zrefclever_nudge_comptosing_bool }
                            { \tl_if_empty_p:N \l__zrefclever_typeset_queue_curr_tl }
                            {
                              \int_compare_p:nNn
                                { \l__zrefclever_label_count_int } > { 0 }
                            }
                          }
                          {
                            \msg_warning:nne { zref-clever }
                              { nudge-comptosing }
                              { \l__zrefclever_type_first_label_type_tl }
                          }
                      }
                    \bool_lazy_and:nnT
                      { \l__zrefclever_nudge_gender_bool }
                      { ! \tl_if_empty_p:N \l__zrefclever_ref_gender_tl }
                      {
                        \__zrefclever_get_rf_opt_seq:neeN { gender }
                          { \l__zrefclever_type_first_label_type_tl }
                          { \l__zrefclever_ref_language_tl }
                          \l__zrefclever_type_name_gender_seq
                        \seq_if_in:NVF
                          \l__zrefclever_type_name_gender_seq
                          \l__zrefclever_ref_gender_tl
                          {
                            \seq_if_empty:NTF \l__zrefclever_type_name_gender_seq
                              {
                                \msg_warning:nneee { zref-clever }
                                  { nudge-gender-not-declared-for-type }
                                  { \l__zrefclever_ref_gender_tl }
                                  { \l__zrefclever_type_first_label_type_tl }
                                  { \l__zrefclever_ref_language_tl }
                              }
                              {
                                \msg_warning:nneeee { zref-clever }
                                  { nudge-gender-mismatch }
                                  { \l__zrefclever_type_first_label_type_tl }
                                  { \l__zrefclever_ref_gender_tl }
                                  {
                                    \seq_use:Nn
                                      \l__zrefclever_type_name_gender_seq { ,~ }
                                  }
                                  { \l__zrefclever_ref_language_tl }
                              }
                          }
                      }
                  }
                \tl_if_empty:NTF \l__zrefclever_name_format_fallback_tl
                  {
                    \__zrefclever_opt_tl_get:cNF
                      {
                        \__zrefclever_opt_varname_type:een
                          { \l__zrefclever_type_first_label_type_tl }
                          { \l__zrefclever_name_format_tl }
                          { tl }
                      }
                      \l__zrefclever_type_name_tl
                      {
                        \tl_if_empty:NF \l__zrefclever_ref_variant_tl
                          {
                            \tl_put_left:Nn \l__zrefclever_name_format_tl { - }
                            \tl_put_left:NV \l__zrefclever_name_format_tl
                              \l__zrefclever_ref_variant_tl
                          }
                        \__zrefclever_opt_tl_get:cNF
                          {
                            \__zrefclever_opt_varname_lang_type:eeen
                              { \l__zrefclever_ref_language_tl }
                              { \l__zrefclever_type_first_label_type_tl }
                              { \l__zrefclever_name_format_tl }
                              { tl }
                          }
                          \l__zrefclever_type_name_tl
                          {
                            \tl_clear:N \l__zrefclever_type_name_tl
                            \bool_set_true:N \l__zrefclever_type_name_missing_bool
                            \msg_warning:nnee { zref-clever } { missing-name }
                              { \l__zrefclever_name_format_tl }
                              { \l__zrefclever_type_first_label_type_tl }
                          }
                      }
                  }
                  {
                    \__zrefclever_opt_tl_get:cNF
                      {
                        \__zrefclever_opt_varname_type:een
                          { \l__zrefclever_type_first_label_type_tl }
                          { \l__zrefclever_name_format_tl }
                          { tl }
                      }
                      \l__zrefclever_type_name_tl
                      {
                        \__zrefclever_opt_tl_get:cNF
                          {
                            \__zrefclever_opt_varname_type:een
                              { \l__zrefclever_type_first_label_type_tl }
                              { \l__zrefclever_name_format_fallback_tl }
                              { tl }
                          }
                          \l__zrefclever_type_name_tl
                          {
                            \tl_if_empty:NF \l__zrefclever_ref_variant_tl
                              {
                                \tl_put_left:Nn
                                  \l__zrefclever_name_format_tl { - }
                                \tl_put_left:NV \l__zrefclever_name_format_tl
                                  \l__zrefclever_ref_variant_tl
                                \tl_put_left:Nn
                                  \l__zrefclever_name_format_fallback_tl { - }
                                \tl_put_left:NV
                                  \l__zrefclever_name_format_fallback_tl
                                  \l__zrefclever_ref_variant_tl
                              }
                            \__zrefclever_opt_tl_get:cNF
                              {
                                \__zrefclever_opt_varname_lang_type:eeen
                                  { \l__zrefclever_ref_language_tl }
                                  { \l__zrefclever_type_first_label_type_tl }
                                  { \l__zrefclever_name_format_tl }
                                  { tl }
                              }
                              \l__zrefclever_type_name_tl
                              {
                                \__zrefclever_opt_tl_get:cNF
                                  {
                                    \__zrefclever_opt_varname_lang_type:eeen
                                      { \l__zrefclever_ref_language_tl }
                                      { \l__zrefclever_type_first_label_type_tl }
                                      { \l__zrefclever_name_format_fallback_tl }
                                      { tl }
                                  }
                                  \l__zrefclever_type_name_tl
                                  {
                                    \tl_clear:N \l__zrefclever_type_name_tl
                                    \bool_set_true:N
                                      \l__zrefclever_type_name_missing_bool
                                    \msg_warning:nnee { zref-clever }
                                      { missing-name }
                                      { \l__zrefclever_name_format_tl }
                                      { \l__zrefclever_type_first_label_type_tl }
                                  }
                              }
                          }
                      }
                  }
              }
          }
        % Signal whether the type name is to be included in the hyperlink or
        % not.
        \bool_lazy_any:nTF
          {
            { ! \l__zrefclever_hyperlink_bool }
            { \l__zrefclever_link_star_bool }
            { \tl_if_empty_p:N \l__zrefclever_type_name_tl }
            { \str_if_eq_p:Vn \l__zrefclever_nameinlink_str { false } }
          }
          { \bool_set_false:N \l__zrefclever_name_in_link_bool }
          {
            \bool_lazy_any:nTF
              {
                { \str_if_eq_p:Vn \l__zrefclever_nameinlink_str { true } }
                {
                  \str_if_eq_p:Vn \l__zrefclever_nameinlink_str { tsingle } &&
                  \tl_if_empty_p:N \l__zrefclever_typeset_queue_curr_tl
                }
                {
                  \str_if_eq_p:Vn \l__zrefclever_nameinlink_str { single } &&
                  \tl_if_empty_p:N \l__zrefclever_typeset_queue_curr_tl &&
                  \l__zrefclever_typeset_last_bool &&
                  \int_compare_p:nNn { \l__zrefclever_type_count_int } = { 0 }
                }
              }
              { \bool_set_true:N \l__zrefclever_name_in_link_bool }
              { \bool_set_false:N \l__zrefclever_name_in_link_bool }
          }
      }
  }
\cs_new_protected:Npn \__zrefclever_hyperlink:nnn #1#2#3
  {
    \tl_if_empty:nTF {#1}
      { \hyperlink {#2} {#3} }
      { \hyper@linkfile {#3} {#1} {#2} }
  }
\cs_new:Npn \__zrefclever_extract_url_unexp:n #1
  {
    \zref@ifpropundefined { urluse }
      { \__zrefclever_extract_unexp:nnn {#1} { url } { } }
      {
        \zref@ifrefcontainsprop {#1} { urluse }
          { \__zrefclever_extract_unexp:nnn {#1} { urluse } { } }
          { \__zrefclever_extract_unexp:nnn {#1} { url } { } }
      }
  }
\cs_generate_variant:Nn \__zrefclever_extract_url_unexp:n { V }
\cs_new_protected:Npn \__zrefclever_labels_in_sequence:nn #1#2
  {
    \exp_args:Nee \tl_if_eq:nnT
      { \__zrefclever_extract_unexp:nnn {#1} { externaldocument } { } }
      { \__zrefclever_extract_unexp:nnn {#2} { externaldocument } { } }
      {
        \tl_if_eq:NnTF \l__zrefclever_ref_property_tl { page }
          {
            \exp_args:Nee \tl_if_eq:nnT
              { \__zrefclever_extract_unexp:nnn {#1} { zc@pgfmt } { } }
              { \__zrefclever_extract_unexp:nnn {#2} { zc@pgfmt } { } }
              {
                \int_compare:nNnTF
                  { \__zrefclever_extract:nnn {#1} { zc@pgval } { -2 } + 1 }
                  =
                  { \__zrefclever_extract:nnn {#2} { zc@pgval } { -1 } }
                  { \bool_set_true:N \l__zrefclever_next_maybe_range_bool }
                  {
                    \int_compare:nNnT
                      { \__zrefclever_extract:nnn {#1} { zc@pgval } { -1 } }
                      =
                      { \__zrefclever_extract:nnn {#2} { zc@pgval } { -1 } }
                      {
                        \bool_set_true:N \l__zrefclever_next_maybe_range_bool
                        \bool_set_true:N \l__zrefclever_next_is_same_bool
                      }
                  }
              }
          }
          {
            \exp_args:Nee \tl_if_eq:nnT
              { \__zrefclever_extract_unexp:nnn {#1} { zc@counter } { } }
              { \__zrefclever_extract_unexp:nnn {#2} { zc@counter } { } }
              {
                \exp_args:Nee \tl_if_eq:nnT
                  { \__zrefclever_extract_unexp:nnn {#1} { zc@enclval } { } }
                  { \__zrefclever_extract_unexp:nnn {#2} { zc@enclval } { } }
                  {
                    \int_compare:nNnTF
                      { \__zrefclever_extract:nnn {#1} { zc@cntval } { -2 } + 1 }
                      =
                      { \__zrefclever_extract:nnn {#2} { zc@cntval } { -1 } }
                      { \bool_set_true:N \l__zrefclever_next_maybe_range_bool }
                      {
                        \int_compare:nNnT
                          { \__zrefclever_extract:nnn {#1} { zc@cntval } { -1 } }
                          =
                          { \__zrefclever_extract:nnn {#2} { zc@cntval } { -1 } }
                          {
                            \exp_args:Nee \tl_if_eq:nnT
                              {
                                \__zrefclever_extract_unexp:nvn {#1}
                                  { l__zrefclever_ref_property_tl } { }
                              }
                              {
                                \__zrefclever_extract_unexp:nvn {#2}
                                  { l__zrefclever_ref_property_tl } { }
                              }
                              {
                                \bool_set_true:N
                                  \l__zrefclever_next_maybe_range_bool
                                \bool_set_true:N
                                  \l__zrefclever_next_is_same_bool
                              }
                          }
                      }
                  }
              }
          }
      }
  }
\cs_new_protected:Npn \__zrefclever_get_rf_opt_tl:nnnN #1#2#3#4
  {
    % First attempt: general options.
    \__zrefclever_opt_tl_get:cNF
      { \__zrefclever_opt_varname_general:nn {#1} { tl } }
      #4
      {
        % If not found, try type specific options.
        \__zrefclever_opt_tl_get:cNF
          { \__zrefclever_opt_varname_type:nnn {#2} {#1} { tl } }
          #4
          {
            % If not found, try type- and language-specific.
            \__zrefclever_opt_tl_get:cNF
              { \__zrefclever_opt_varname_lang_type:nnnn {#3} {#2} {#1} { tl } }
              #4
              {
                % If not found, try language-specific default.
                \__zrefclever_opt_tl_get:cNF
                  { \__zrefclever_opt_varname_lang_default:nnn {#3} {#1} { tl } }
                  #4
                  {
                    % If not found, try fallback.
                    \__zrefclever_opt_tl_get:cNF
                      { \__zrefclever_opt_varname_fallback:nn {#1} { tl } }
                      #4
                      { \tl_clear:N #4 }
                  }
              }
          }
      }
  }
\cs_generate_variant:Nn \__zrefclever_get_rf_opt_tl:nnnN { neeN }
\cs_new_protected:Npn \__zrefclever_get_rf_opt_seq:nnnN #1#2#3#4
  {
    % First attempt: general options.
    \__zrefclever_opt_seq_get:cNF
      { \__zrefclever_opt_varname_general:nn {#1} { seq } }
      #4
      {
        % If not found, try type specific options.
        \__zrefclever_opt_seq_get:cNF
          { \__zrefclever_opt_varname_type:nnn {#2} {#1} { seq } }
          #4
          {
            % If not found, try type- and language-specific.
            \__zrefclever_opt_seq_get:cNF
              { \__zrefclever_opt_varname_lang_type:nnnn {#3} {#2} {#1} { seq } }
              #4
              {
                % If not found, try language-specific default.
                \__zrefclever_opt_seq_get:cNF
                  { \__zrefclever_opt_varname_lang_default:nnn {#3} {#1} { seq } }
                  #4
                  {
                    % If not found, try fallback.
                    \__zrefclever_opt_seq_get:cNF
                      { \__zrefclever_opt_varname_fallback:nn {#1} { seq } }
                      #4
                      { \seq_clear:N #4 }
                  }
              }
          }
      }
  }
\cs_generate_variant:Nn \__zrefclever_get_rf_opt_seq:nnnN { neeN }
\cs_new_protected:Npn \__zrefclever_get_rf_opt_bool:nnnnN #1#2#3#4#5
  {
    % First attempt: general options.
    \__zrefclever_opt_bool_get:cNF
      { \__zrefclever_opt_varname_general:nn {#1} { bool } }
      #5
      {
        % If not found, try type specific options.
        \__zrefclever_opt_bool_get:cNF
          { \__zrefclever_opt_varname_type:nnn {#3} {#1} { bool } }
          #5
          {
            % If not found, try type- and language-specific.
            \__zrefclever_opt_bool_get:cNF
              { \__zrefclever_opt_varname_lang_type:nnnn {#4} {#3} {#1} { bool } }
              #5
              {
                % If not found, try language-specific default.
                \__zrefclever_opt_bool_get:cNF
                  { \__zrefclever_opt_varname_lang_default:nnn {#4} {#1} { bool } }
                  #5
                  {
                    % If not found, try fallback.
                    \__zrefclever_opt_bool_get:cNF
                      { \__zrefclever_opt_varname_fallback:nn {#1} { bool } }
                      #5
                      { \use:c { bool_set_ #2 :N } #5 }
                  }
              }
          }
      }
  }
\cs_generate_variant:Nn \__zrefclever_get_rf_opt_bool:nnnnN { nneeN }
\__zrefclever_compat_module:nn { appendix }
  {
    \newcounter { zc@appendix }
    \cs_if_exist:cTF { chapter }
      {
        \__zrefclever_zcsetup:e
          {
            counterresetby =
              {
                zc@appendix = \__zrefclever_counter_reset_by:n { chapter } ,
                chapter = zc@appendix ,
              } ,
          }
      }
      {
        \cs_if_exist:cT { section }
          {
            \__zrefclever_zcsetup:e
              {
                counterresetby =
                  {
                    zc@appendix = \__zrefclever_counter_reset_by:n { section } ,
                    section = zc@appendix ,
                  } ,
              }
          }
      }
    \AddToHook { cmd / appendix / before }
      {
        \setcounter { zc@appendix } { 1 }
        \__zrefclever_zcsetup:n
          {
            countertype =
              {
                chapter       = appendix ,
                section       = appendix ,
                subsection    = appendix ,
                subsubsection = appendix ,
                paragraph     = appendix ,
                subparagraph  = appendix ,
              }
          }
      }
  }
\__zrefclever_compat_module:nn { appendices }
  {
    \__zrefclever_if_package_loaded:nT { appendix }
      {
        \AddToHook { env / appendices / begin }
          {
            \setcounter { zc@appendix } { 1 }
            \__zrefclever_zcsetup:n
              {
                countertype =
                  {
                    chapter       = appendix ,
                    section       = appendix ,
                    subsection    = appendix ,
                    subsubsection = appendix ,
                    paragraph     = appendix ,
                    subparagraph  = appendix ,
                  }
              }
          }
        \AddToHook { env / appendices / end }
          { \setcounter { zc@appendix } { 0 } }
        \newcounter { zc@subappendix }
        \cs_if_exist:cTF { chapter }
          {
            \__zrefclever_zcsetup:e
              {
                counterresetby =
                  {
                    zc@subappendix = \__zrefclever_counter_reset_by:n { section } ,
                    section = zc@subappendix ,
                  } ,
              }
          }
          {
            \__zrefclever_zcsetup:e
              {
                counterresetby =
                  {
                    zc@subappendix = \__zrefclever_counter_reset_by:n { subsection } ,
                    subsection = zc@subappendix ,
                  } ,
              }
          }
        \AddToHook { env / subappendices / begin }
          {
            \setcounter { zc@subappendix } { 1 }
            \__zrefclever_zcsetup:n
              {
                countertype =
                  {
                    section       = appendix ,
                    subsection    = appendix ,
                    subsubsection = appendix ,
                    paragraph     = appendix ,
                    subparagraph  = appendix ,
                  } ,
              }
          }
        \AddToHook { env / subappendices / end }
          { \setcounter { zc@subappendix } { 0 } }
        \msg_info:nnn { zref-clever } { compat-package } { appendix }
      }
  }
\__zrefclever_compat_module:nn { memoir }
  {
    \__zrefclever_if_class_loaded:nT { memoir }
      {
        \__zrefclever_zcsetup:n
          {
            countertype =
              {
                subfigure = figure ,
                subtable  = table ,
                poemline  = line ,
              } ,
            counterresetby =
              {
                subfigure = figure ,
                subtable  = table ,
              } ,
          }
        \zref@newprop { subcaption }
          { \cs_if_exist_use:c { @@thesub \@captype } }
        \AddToHook{ memoir/subcaption/aftercounter }
          { \zref@localaddprop \ZREF@mainlist { subcaption } }
        \__zrefclever_zcsetup:n
          {
            countertype =
              {
                sidefootnote = footnote ,
                pagenote = endnote ,
              } ,
          }
        \msg_info:nnn { zref-clever } { compat-class } { memoir }
      }
  }
\__zrefclever_compat_module:nn { amsmath }
  {
    \__zrefclever_if_package_loaded:nT { amsmath }
      {
        \bool_new:N \l__zrefclever_amsmath_subequations_bool
        \AddToHook { env / subequations / begin }
          {
            \__zrefclever_zcsetup:e
              {
                counterresetby =
                  {
                    parentequation =
                      \__zrefclever_counter_reset_by:n { equation } ,
                    equation = parentequation ,
                  } ,
                currentcounter = parentequation ,
                countertype = { parentequation = equation } ,
              }
            \bool_set_true:N \l__zrefclever_amsmath_subequations_bool
          }
        \zref@newprop { subeq } { \alph { equation } }
        \clist_map_inline:nn
          {
            equation ,
            equation* ,
            align ,
            align* ,
            alignat ,
            alignat* ,
            flalign ,
            flalign* ,
            xalignat ,
            xalignat* ,
            gather ,
            gather* ,
            multline ,
            multline* ,
          }
          {
            \AddToHook { env / #1 / begin }
              {
                \__zrefclever_zcsetup:n { currentcounter = equation }
                \bool_if:NT \l__zrefclever_amsmath_subequations_bool
                  { \zref@localaddprop \ZREF@mainlist { subeq } }
              }
          }
        \msg_info:nnn { zref-clever } { compat-package } { amsmath }
      }
  }
\bool_new:N \l__zrefclever_mathtools_loaded_bool
\__zrefclever_compat_module:nn { mathtools }
  {
    \__zrefclever_if_package_loaded:nT { mathtools }
      {
        \bool_set_true:N \l__zrefclever_mathtools_loaded_bool
        \cs_new_protected:Npn \__zrefclever_mathtools_showonlyrefs:n #1
          {
            \seq_map_inline:Nn #1
              {
                \tl_set:Ne \l__zrefclever_tmpa_tl
                  { \__zrefclever_extract_unexp:nnn {##1} { zc@type } { } }
                \bool_lazy_or:nnT
                  { \str_if_eq_p:Vn \l__zrefclever_tmpa_tl { equation } }
                  { \str_if_eq_p:Vn \l__zrefclever_tmpa_tl { parentequation } }
                  { \noeqref {##1} }
              }
          }
        \msg_info:nnn { zref-clever } { compat-package } { mathtools }
      }
  }
\__zrefclever_compat_module:nn { breqn }
  {
    \__zrefclever_if_package_loaded:nT { breqn }
      {
        \bool_new:N \l__zrefclever_breqn_dgroup_bool
        \AddToHook { env / dgroup / begin }
          {
            \__zrefclever_zcsetup:e
              {
                counterresetby =
                  {
                    parentequation =
                      \__zrefclever_counter_reset_by:n { equation } ,
                    equation = parentequation ,
                  } ,
                currentcounter = parentequation ,
                countertype = { parentequation = equation } ,
              }
            \bool_set_true:N \l__zrefclever_breqn_dgroup_bool
          }
        \zref@ifpropundefined { subeq }
          { \zref@newprop { subeq } { \alph { equation } } }
          { }
        \clist_map_inline:nn
          {
            dmath ,
            dseries ,
            darray ,
          }
          {
            \AddToHook { env / #1 / begin }
              {
                \__zrefclever_zcsetup:n { currentcounter = equation }
                \bool_if:NT \l__zrefclever_breqn_dgroup_bool
                  { \zref@localaddprop \ZREF@mainlist { subeq } }
              }
          }
        \msg_info:nnn { zref-clever } { compat-package } { breqn }
      }
  }
\__zrefclever_compat_module:nn { listings }
  {
    \__zrefclever_if_package_loaded:nT { listings }
      {
        \__zrefclever_zcsetup:n
          {
            countertype =
              {
                lstlisting = listing ,
                lstnumber = line ,
              } ,
            counterresetby = { lstnumber = lstlisting } ,
          }
        \cs_if_exist:NT \lst@AddToHook
          {
            \lst@AddToHook { Init }
              { \__zrefclever_zcsetup:n { currentcounter = lstnumber } }
          }
        \msg_info:nnn { zref-clever } { compat-package } { listings }
      }
  }
\__zrefclever_compat_module:nn { enumitem }
  {
    \__zrefclever_if_package_loaded:nT { enumitem }
      {
        \int_set:Nn \l__zrefclever_tmpa_int { 5 }
        \bool_while_do:nn
          {
            \cs_if_exist_p:c
              { c@ enum \int_to_roman:n { \l__zrefclever_tmpa_int } }
          }
          {
            \__zrefclever_zcsetup:e
              {
                counterresetby =
                  {
                    enum \int_to_roman:n { \l__zrefclever_tmpa_int } =
                    enum \int_to_roman:n { \l__zrefclever_tmpa_int - 1 }
                  } ,
                countertype =
                  { enum \int_to_roman:n { \l__zrefclever_tmpa_int } = item } ,
              }
            \int_incr:N \l__zrefclever_tmpa_int
          }
        \int_compare:nNnT { \l__zrefclever_tmpa_int } > { 5 }
          { \msg_info:nnn { zref-clever } { compat-package } { enumitem } }
      }
  }
\__zrefclever_compat_module:nn { subcaption }
  {
    \__zrefclever_if_package_loaded:nT { subcaption }
      {
        \__zrefclever_zcsetup:n
          {
            countertype =
              {
                subfigure = figure ,
                subtable = table ,
              } ,
            counterresetby =
              {
                subfigure = figure ,
                subtable = table ,
              } ,
          }
        \zref@newprop { subref }
          { \cs_if_exist_use:c { thesub \@captype } }
        \tl_if_exist:NT \caption@subtypehook
          {
            \tl_put_right:Nn \caption@subtypehook
              { \zref@localaddprop \ZREF@mainlist { subref } }
          }
      }
  }
\__zrefclever_compat_module:nn { subfig }
  {
    \__zrefclever_if_package_loaded:nT { subfig }
      {
        \__zrefclever_zcsetup:n
          {
            countertype =
              {
                subfigure = figure ,
                subtable = table ,
              } ,
            counterresetby =
              {
                subfigure = figure ,
                subtable = table ,
              } ,
          }
      }
  }
\__zrefclever_compat_module:nn { beamer }
  {
    \__zrefclever_if_class_loaded:nT { beamer }
      {
        \AddToHookWithArguments { label } [ zref-clever/compat/beamer ]
          { \xdef\@currentHref{#1} }
        \DeclareHookRule { label }
          { zref-clever/compat/beamer } { before } { zref-clever }
        \AddToHookWithArguments { cmd/refcounter/before }
          [ zref-clever/compat/beamer ]
          { \edef\@currentcounter{#1} }
      }
  }
\zcDeclareLanguage { english }
\zcDeclareLanguageAlias { american   } { english }
\zcDeclareLanguageAlias { australian } { english }
\zcDeclareLanguageAlias { british    } { english }
\zcDeclareLanguageAlias { canadian   } { english }
\zcDeclareLanguageAlias { newzealand } { english }
\zcDeclareLanguageAlias { UKenglish  } { english }
\zcDeclareLanguageAlias { USenglish  } { english }
\zcDeclareLanguage
  [ variants = { N , A , D , G } , gender = { f , m , n } , allcaps ]
  { german }
\zcDeclareLanguageAlias { ngerman      } { german }
\zcDeclareLanguageAlias { austrian     } { german }
\zcDeclareLanguageAlias { naustrian    } { german }
\zcDeclareLanguageAlias { swissgerman  } { german }
\zcDeclareLanguageAlias { nswissgerman } { german }
\zcDeclareLanguage [ gender = { f , m } ] { french }
\zcDeclareLanguageAlias { acadian  } { french }
\zcDeclareLanguage [ gender = { f , m } ] { portuguese }
\zcDeclareLanguageAlias { brazilian } { portuguese }
\zcDeclareLanguageAlias { brazil    } { portuguese }
\zcDeclareLanguageAlias { portuges  } { portuguese }
\zcDeclareLanguage [ gender = { f , m } ] { spanish }
\zcDeclareLanguage [ gender = { f , m , n } ] { dutch }
\zcDeclareLanguage [ gender = { f , m } ] { italian }
\zcDeclareLanguage
  [ variants = { n , a , g , d , i , p } , gender = { f , m , n } ]
  { russian }
\zcDeclareLanguage { swedish }
%% 
%%
%% End of file `zref-clever.sty'.
