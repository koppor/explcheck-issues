%%
%% This is file `prooftrees.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% prooftrees.dtx  (with options: `sty')
%% -------------------------------------------------
%% Copyright (C) 2016-2025 Clea F. Rees.
%% 
%% This work may be distributed and/or modified under the
%% conditions of the LaTeX Project Public License, either version 1.3c
%% of this license or (at your option) any later version.
%% The latest version of this license is in
%%   https://www.latex-project.org/lppl.txt
%% and version 1.3c or later is part of all distributions of LaTeX
%% version 2008-05-04 or later.
%% 
%% This work has the LPPL maintenance status `maintained'.
%% 
%% The Current Maintainer of this work is Clea F. Rees.
%% 
%% This file may only be distributed together with a copy of the package
%% prooftrees. You may however distribute the package prooftrees without
%% such generated files.
%% 
%% This work consists of all files listed in manifest.txt.
%% -------------------------------------------------
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{svn-prov}
\ProvidesPackageSVN[\filebase.sty]{$Id: prooftrees.dtx 11204 2025-09-04 03:23:15Z cfrees $}[v0.9.1 \revinfo]
\DefineFileInfoSVN
\newcommand*\prooftrees@enw{prooftree}
\DeclareOption{tableaux}{\renewcommand*\prooftrees@enw{tableau}}
\DeclareOption{tableau}{\renewcommand*\prooftrees@enw{tableau}}
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{forest}}
\ifcsname prooftree\endcsname
  \renewcommand*\prooftrees@enw{tableau}%
\else
  \renewcommand*\prooftrees@enw{prooftree}%
\fi
\ProcessOptions
\RequirePackage{forest}[2016/12/04]
\newcommand*\linenumberstyle[1]{#1.}
\newtoks\prooftrees@tableau@toks
\forestset{%
  declare boolean register={line numbering},
  line numbering,
  declare boolean register={justifications},
  not justifications,
  declare boolean register={single branches},
  not single branches,
  declare boolean register={auto move},% ble mae'n bosibl, symud pethau'n awtomatig
  auto move,
  declare dimen register={line no width},
  line no width'=0pt,
  declare dimen register={just sep},
  just sep'=1.5em,
  declare dimen register={just dist},
  just dist'=0pt,
  declare dimen register={line no sep},
  line no sep'=1.5em,
  declare dimen register={line no dist},
  line no dist'=0pt,
  declare dimen register={close sep},
  close sep'=.75\baselineskip,
  declare dimen register={proof tree line no x},
  proof tree line no x'=0pt,
  declare dimen register={proof tree justification x},
  proof tree justification x'=0pt,
  declare dimen register={proof tree inner proof width},
  proof tree inner proof width'=0pt,
  declare dimen register={proof tree inner proof midpoint},
  proof tree inner proof midpoint'=0pt,
  declare count register={proof tree rhif lefelau},
  proof tree rhif lefelau'=0,
  declare count register={proof tree lcount},
  proof tree lcount'=0,
  declare count register={proof tree jcount},
  proof tree jcount'=0,
  declare count register={line no shift},
  line no shift'=0,
  declare count register={proof tree aros},
  proof tree aros'=0,
  declare toks register={check with},
  check with={\ensuremath{\checkmark}},
  declare boolean register={check right},
  check right,
  check left/.style={not check right},
  declare toks register={subs with},
  subs with={\ensuremath{\backslash}},
  declare boolean register={subs right},
  subs right,
  subs left/.style={not subs right},
  declare toks register={close with},
  close with={\ensuremath{\otimes}},
  declare keylist register={close format},
  close format={font=\scriptsize},
  declare keylist register={close with format},
  close with format={},
  declare toks register={merge delimiter},
  merge delimiter={\text{; }},
  declare boolean register={just refs left},
  just refs left,
  just refs right/.style={not just refs left},
  declare keylist register={just format},
  just format={},
  declare keylist register={line no format},
  line no format={},
  declare autowrapped toks register={highlight format},
  highlight format={draw=gray, rounded corners},
  declare keylist register={proof statement format},
  proof statement format={},
  declare keylist register={wff format},
  wff format={},
  declare boolean={proof tree justification}{0},
  declare boolean={proof tree line number}{0},
  declare boolean={grouped}{0},
  declare boolean={proof tree phantom}{0},
  declare boolean={highlight wff}{0},
  declare boolean={highlight just}{0},
  declare boolean={highlight line no}{0},
  declare boolean={highlight line}{0},
  Autoforward={highlight line}{highlight just, highlight wff, highlight line no},
  declare boolean={proof tree toing}{0},
  declare boolean={proof tree toing with}{0},
  declare boolean={proof tree rhiant cymysg}{0},
  declare boolean={proof tree rhifo}{1},
  declare boolean={proof tree arweinydd}{0},
  declare autowrapped toks={just}{},
  declare toks={proof tree rhestr rhifau llinellau}{},
  declare toks={proof tree close}{},
  declare toks={proof tree rhestr rhifau llinellau cau}{},
  declare autowrapped toks={just options}{},
  declare autowrapped toks={line no options}{},
  declare autowrapped toks={wff options}{},
  declare autowrapped toks={line options}{},
  Autoforward={line options}{just options={#1}, line no options={#1}, wff options={#1}},
  declare count={proof tree toing by}{0},
  declare count={proof tree cadw toing by}{0},
  declare count={proof tree toooing}{0},
  declare count={proof tree proof line no}{0},
  declare keylist={proof tree jrefs}{},
  declare keylist={proof tree crefs}{},
  declare keylist={proof tree ffurf}{},
  declare keylist={proof tree symud awto}{},
  declare keylist={proof tree creu nodiadau}{},
  declare keylist={proof tree nodiadau}{},
  declare keylist={before copying content}{},
  declare keylist={proof tree copy content}{},
  declare keylist={proof tree after copying content}{},
  declare keylist={proof tree before typesetting nodes}{},
  declare keylist={proof tree before packing}{},
  declare keylist={proof tree before computing xy}{},
  declare keylist={proof tree before drawing tree}{},
  declare keylist={before making annotations}{},
  declare keylist={before annotating}{},
  declare boolean register={tag},
  tag=0,
  declare toks register={plug},
  declare toks register={tag check with},
  tag check with={discharged},
  declare toks register={tag close with},
  tag close with={closed},
  declare toks register={tag subs with},
  tag subs with={substituted},
  declare toks register={tag to prove},
  tag to prove={To prove: },
  declare keylist={before making tags}{},
  declare keylist={proof tree make tags}{},
  declare keylist={before getting tags}{},
  declare keylist={proof tree get tags}{},
  declare toks={ttoks}{},
  define long step={proof tree symud}{}{%
    root,sort by={>{O}{level},>{_O<}{1}{n children}},sort'=descendants
  },
  define long step={proof tree cywiro symud}{}{%
    root,if line numbering={n=2}{n=1},sort by={>{O}{level},>{_O<}{1}{n children}},sort'=descendants
  },
  define long step={proof tree camau}{}{%
    root,sort by={>{O}{y},>{Ow1+d}{x}{-##1}},sort'={filter={descendants}{>{OO!&}{proof tree rhifo}{proof tree phantom}}}%
  },
  define long step={proof tree wffs}{}{%
    fake=root,if line numbering={n=2}{n=1},tree
  },
  define long step={every wff}{}{%
    unique={name=proof statement,proof tree wffs}%
  },
  proof tree get tags processing order=every wff,
  define long step={wffs from proof line no to}{n args=2}{
    sort by={>O{proof tree proof line no}},
    sort={filter={proof tree wffs}{> nO< nO> O! &&{#1-1}{proof tree proof line no}{#2+1}{proof tree proof line no}{phantom}}}%
  },
  checked/.style={%
    proof tree after copying content={%
      if check right={%
        content+'={\ \forestregister{check with}#1},
      }{%
        +content'={\forestregister{check with}#1\ },
      },
    },
  },
  subs/.style={%
    proof tree after copying content={%
      if subs right={%
        content+'={\ \forestregister{subs with}#1},
      }{%
        +content'={\forestregister{subs with}#1\ },
      },
    },
  },
  close/.style={%
    if={%
      >{__=}{#1}{}%
    }{}{%
      temptoksb={},
      temptoksa={#1},
      split register={temptoksa}{:}{proof tree close,temptoksb},
      if temptoksb={}{}{%
        split register={temptoksb}{,}{proof tree cref},
      },
    },
    proof tree after copying content={%
      append={%
        [\forestregister{close with},
          not proof tree rhifo,
          proof tree phantom,
          grouped,
          no edge,
          process keylist register=close with format,
          proof tree before computing xy={%
            delay={%
              l'=\baselineskip,%
              for children={%
                l/.register=close sep,
              },
            },
          },
          proof tree before drawing tree={%
            if={>{RR|}{line numbering}{justifications}}{%
              proof tree proof line no/.option=!parent.proof tree proof line no,
            }{},
          },
          if={%
            >{__=}{#1}{}%
          }{}{%
            delay={%
              append={%
                [,
                  not proof tree rhifo,
                  proof tree phantom,
                  grouped,
                  no edge,
                  process keylist register=close format,
                  if={%
                    >{O_=}{!parent,parent.proof tree close}{}%
                  }{}{content/.option=!{parent,parent}.proof tree close},
                  proof tree crefs/.option=!{parent,parent}.proof tree crefs,
                  delay={%
                    !{parent,parent}.proof tree crefs'={},
                  },
                  proof tree before drawing tree={%
                    if={>{RR|}{line numbering}{justifications}}{%
                      proof tree proof line no/.option=!{parent,parent}.proof tree proof line no,
                    }{},
                  },
                ]%
              },
            },
          },
        ]%
      },
    },
  },
  proof tree line no/.style={%
    anchor=base west,
    no edge,
    proof tree line number,
    text width/.register=line no width,
    x'/.register=proof tree line no x,
    process keylist register=line no format,
    delay={%
      proof tree lcount'+=1,
      tempcounta/.process={RRw2+n}{proof tree lcount}{line no shift}{##1+##2},
      content/.process={Rw1}{tempcounta}{\linenumberstyle{##1}},% content i.e. the line number
      name/.expanded={line no \foresteregister{tempcounta}},%
      typeset node,
      if proof tree lcount>=3{%
        for previous={%
          append/.expanded={line no \foresteregister{tempcounta}}
        },
      }{},
    },
  },
  proof tree line justification/.style={%
    anchor=base west,
    no edge,
    proof tree justification,
    x'/.register=proof tree justification x,
    process keylist register=just format,
    delay={%
      proof tree jcount'+=1,
      tempcounta/.process={RRw2+n}{proof tree jcount}{line no shift}{##1+##2},
      name/.expanded={just \foresteregister{tempcounta}},
      typeset node,
      if proof tree jcount>=3{%
        for previous={%
          append/.expanded={just \foresteregister{tempcounta}},
        },
      }{},
    },
  },
  zero start/.style={%
    line no shift'+=-1,
  },
  to prove/.style={%
    for root={%
      proof tree before typesetting nodes={%
        content={#1},
        phantom=false,
        baseline,
        if line numbering={anchor=base west}{anchor=base},
        process keylist register=proof statement format,
      },
      proof tree before computing xy={%
        delay={%
          for children={%
            l=1.5*\baselineskip,
          },
        },
      },
    },
  },
  proof tree/.style={%
    for tree={%
      parent anchor=children,
      child anchor=parent,
      math content,
      delay={%
        if just={}{}{%
          justifications,
          temptoksa={},
          split option={just}{:}{just,temptoksa},
          if temptoksa={}{}{%
            split register={temptoksa}{,}{proof tree jref},
          },
        },
        if content={}{% if there's no proof statement
          if level=0{}{%
            shape=coordinate,
          },
        }{},
      },
    },
    where level=0{%
      for children={%
        proof tree before typesetting nodes={%
          no edge,
        },
      },
      delay={%
        if content={}{phantom}{},
        if line numbering={%
          parent anchor=south west,
          if line no width={0pt}{%
            line no width/.pgfmath={width("\noexpand\linenumberstyle{99}")},
          }{},
        }{},
      },
      proof tree creu nodiadau={%
        if={>{RR|}{line numbering}{justifications}}{%
          proof tree rhif lefelau'/.register=line no shift,
          for proof tree camau={%
            if level>=1{%
              if={%
                >{OO<}{y}{!back.y}%
              }{%
                proof tree rhif lefelau'+=1,
                proof tree proof line no'/.register=proof tree rhif lefelau,
              }{%
                proof tree proof line no'/.register=proof tree rhif lefelau
              },
            }{},
          },
          proof tree inner proof midpoint/.min={%
            >{OOw2+d}{x}{min x}{##1+##2}%
          }{fake=root,descendants},
          proof tree inner proof width/.max={%
            >{OOw2+d}{x}{max x}{##1+##2}%
          }{fake=root,descendants},
          proof tree inner proof width-/.register=proof tree inner proof midpoint,
          proof tree inner proof midpoint+/.process={%
            Rw+d{proof tree inner proof width}{##1/2}%
          },
        }{},
        if line numbering={%
          proof tree line no x/.min={>{OOw2+d}{x}{min x}{##1+##2}}{fake=root,descendants},
          if={%
            > Rd= {line no dist}{0pt}%
          }{%
            proof tree line no x-/.register=line no sep,
          }{%
            tempdima/.register=proof tree inner proof width,
            tempdima:=2,
            if={%
              > RR< {line no dist}{tempdima}%
            }{}{%
              proof tree line no x/.register=proof tree inner proof midpoint,
              proof tree line no x-/.register=line no dist,
            },
          },
          proof tree line no x-/.register=line no width,
          for root={%
            tempdimc/.option=x,
            x'+/.register=proof tree line no x,
            x'-/.option=min x,
          },
          prepend={%
            [,
              proof tree line no,
              repeat={((proof_tree_rhif_lefelau)-1)-(line_no_shift)}{%
                delay n={proof_tree_lcount}{
                  append={[, proof tree line no]},
                },
              },
            ]%
          },
        }{},
        if justifications={%
          proof tree justification x/.max={%
            >{OOw2+d}{x}{max x}{##1+##2}%
          }{fake=root,descendants},
          if={%
            > Rd= {just dist}{0pt}%
          }{%
            proof tree justification x+/.register=just sep,
          }{%
            tempdima/.register=proof tree inner proof width,
            tempdima:=2,
            if={%
              > RR< {just dist}{tempdima}%
            }{}{%
              proof tree justification x/.register=proof tree inner proof midpoint,
              proof tree justification x+/.register=just dist,
            },
          },
          append={%
            [,
              proof tree line justification,
              repeat={((proof_tree_rhif_lefelau)-1)-(line_no_shift)}{%
                delay n={proof_tree_jcount}{%
                  append={[, proof tree line justification]},
                },
              }%
            ]%
          },
        }{},
      },
    }{%
      delay={%
        if single branches={}{%
          if n children=1{%
            for children={%
              grouped,
            },
          }{},
        },
      },
      proof tree before typesetting nodes={%
        process keylist register=wff format,
        if highlight wff={node options/.register=highlight format}{},
        node options/.option=wff options,
      },
    },
    proof tree ffurf={%
      if auto move={%
        if single branches={%
          where={%
            >{O! _O< O &&}{grouped}{2}{level}{proof tree rhifo}%
          }{%
            if={%
              >{_O= _O< &}{1}{!parent.n children}{1}{!parent,parent.n children}%
            }{%
              not tempboola,
              for root/.process={Ow1}{level}{%
                for level={##1}{%
                  if={%
                    >{_O< _O= &}{1}{!parent.n children}{1}{n}%
                  }{%
                    tempboola,
                  }{},
                },
              },
              if tempboola={%
                proof tree toing,
              }{},
            }{},
          }{},
        }{},
        where={%
          >{O _O< O &&}{grouped}{1}{level}{proof tree rhifo}%
        }{%
          not tempboola,
          for root/.process={Ow1}{level}{%
            for level={##1}{%
              if={%
                >{_O< _O= &}{1}{!parent.n children}{1}{n}%
              }{%
                tempboola,
              }{},
            },
          },%
          if tempboola={%
            if n children=0{%
              if={>{OO|}{!parent.proof tree toing}{!parent.proof tree toing with}}{%
                proof tree toing with,
              }{%
                for root/.process={Ow1}{level}{%
                  for level={##1}{%
                    if={%
                      >{_O< _O= &}{1}{!parent.n children}{1}{n}%
                    }{%
                      for parent={%
                        if proof tree rhiant cymysg={}{%
                          proof tree rhiant cymysg,
                          for descendants={%
                            proof tree toing by'+=1,
                          },
                        },
                      },
                    }{},
                  },
                },%
              },
              no edge,
            }{%
              if={%
                >{_O= _O< &}{1}{!parent.n children}{1}{!parent,parent.n children}%
              }{%
                proof tree toing,
              }{no edge},
            },
          }{no edge},
        }{},
      }{},
    },
    proof tree symud awto={%
      if auto move={%
        proof tree aros'=0,
        for proof tree symud={%
          if proof tree toing={%
            for nodewalk={fake=parent,fake=sibling,descendants}{do dynamics},
            delay n={\foresteregister{proof tree aros}}{%
              tempcounta/.max={%
                >{OOOOw4+n}{level}{proof tree toing by}{proof tree toooing}%
                {proof tree rhifo}{(##1+##2+##3)*##4}%
              }{parent,sibling,descendants},
              if tempcounta>=1{%
                if={%
                  >{Rw1+n OOw2+n >}{tempcounta}{##1+1}{level}{proof tree toing by}{##1+##2}%
                }{%
                  tempcounta-/.option=level,
                  tempcounta'+=1,
                  move by/.register=tempcounta,
                }{no edge},
              }{no edge},
            },
            proof tree aros'+=4,
          }{},
        },
      }{},
    },
    proof tree nodiadau={%
      where proof tree crefs={}{}{%
        split option={proof tree crefs}{,}{proof tree rhif llinell cau},
        if content={}{%
          content/.option=proof tree rhestr rhifau llinellau cau,
        }{%
          content+/.process={_O}{\ }{proof tree rhestr rhifau llinellau cau},
        },
        typeset node,
      },
      if line numbering={%
        for proof tree wffs={%
          if highlight line no={%
            for name/.process={Ow1OOOw3}{proof tree proof line no}{line no ##1}{proof tree proof line no}{line no options}{y}{%
              node options/.register=highlight format,
              ##2,
              y'=##3,
              proof tree proof line no'=##1,
              typeset node,
            }%
          }{%
            if line no options={}{%
              if proof tree phantom={}{%
                for name/.process={Ow1OOw2}{proof tree proof line no}{line no ##1}{proof tree proof line no}{y}{%
                  y'=##2,
                  proof tree proof line no'=##1,
                }%
              },
            }{%
              for name/.process={Ow1OOOw3}{proof tree proof line no}{line no ##1}{proof tree proof line no}{line no options}{y}{%
                ##2,
                y'=##3,
                proof tree proof line no'=##1,
                typeset node,
              }%
            },
          },
        },
      }{},
      if justifications={%
        for proof tree wffs={%
          if just={}{%
            if proof tree phantom={}{%
              for name/.process={Ow1OOw2}{proof tree proof line no}{just ##1}{proof tree proof line no}{y}{%
                y'=##2,
                proof tree proof line no'=##1,
              }%
            },
          }{%
            if proof tree jrefs={}{}{%
              split option={proof tree jrefs}{,}{proof tree rhif llinell},
              if just refs left={%
                +just/.process={O_}{proof tree rhestr rhifau llinellau}{\ },
              }{%
                just+/.process={_O}{\ }{proof tree rhestr rhifau llinellau},
              },
            },
            if highlight just={%
              for name/.process={Ow1OOOOw4}{proof tree proof line no}{just ##1}{proof tree proof line no}{just}{just options}{y}{%
                if={%
                 >{O_= O_= |}{content}{}{content}{##2}%
                }{%
                  content={##2},
                }{%
                  content+'={\foresteregister{merge delimiter}##2},
                  TeX={\PackageWarning{prooftrees}{Merging conflicting justifications for line ##1! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.}},
                },
                node options/.register=highlight format,
                ##3,
                y'=##4,
                proof tree proof line no'=##1,
                typeset node,
              }%^^A do NOT put a comma here!
            }{%
              for name/.process={Ow1OOOOw4}{proof tree proof line no}{just ##1}{proof tree proof line no}{just}{just options}{y}{%
                if={%
                 >{O_= O_= |}{content}{}{content}{##2}%
                }{%
                  content={##2},
                }{%
                  content+'={\foresteregister{merge delimiter}##2},
                  TeX={\PackageWarning{prooftrees}{Merging conflicting justifications for line ##1! Please examine the output carefully and use "move by" to move lines later in the proof if required. Details of how to do this are included in the documentation.}},
                },
                ##3,
                y'=##4,
                proof tree proof line no'=##1,
                typeset node,
              }%^^A do NOT put a comma here!
            }
          },
        },
      }{},
      for proof tree wffs={%
        if proof tree phantom={}{%
          if highlight line={%
            for proof tree wffs/.process={OOw2}{proof tree proof line no}{line options}{%
              if proof tree proof line no={##1}{%
                node options/.register=highlight format,
                ##2,
              }{}%
            },
          }{%
            for proof tree wffs/.process={OOw2}{proof tree proof line no}{line options}{%
              if proof tree proof line no={##1}{##2}{},
            },
          },
          delay={typeset node},
        },
      },
    },
    proof tree before packing={%
      for tree={%
        tier/.process={OOw2+nw1}{level}{proof tree toing by}{##1+##2}{tier ##1},
      },
      for root={%
        if content={}{%
          !{n=1}.baseline,
        }{},
      },
    },
    proof tree before computing xy={%
      for tree={%
        if={%
         >{O _O< &}{grouped}{1}{level}%
       }{%
         not tempboola,
         tempcounta/.option=level,
         tempcountb/.option=proof tree toing,
         tempcountb+/.option=proof tree toooing,
         for nodewalk={fake=root, descendants}{if={> RO= On>  O! O! OOw2+nR= &&&&
             {tempcounta}{level} {!u.n children}{1} {proof tree arweinydd} {proof tree phantom} {proof tree toing by} {proof tree toooing}{##1+##2} {tempcountb}
           }{tempboola}{}},
         if tempboola={}{l'=\baselineskip},
       }{},
      },
    },
    proof tree before drawing tree={%
      if={>{RR|R!&}{line numbering}{justifications}{single branches}}{%
        tempdimc'=0pt,
        for proof tree cywiro symud={%
          if proof tree arweinydd={%
            tempdima'/.option=y,
            if line numbering={%
              for name/.process={Ow1+nw1}{proof tree proof line no}{##1-1}{line no ##1}{% arafach ?
                tempdimb'/.option=y,
              }%
            }{%
              for name/.process={Ow1+nw1}{proof tree proof line no}{##1-1}{just ##1}{% arafach ?
                tempdimb'/.option=y,
              }%
            },
            for parent={%
              y'/.register=tempdimb,
            },
            if tempdimb<={0pt}{%
              tempdimb'-=\baselineskip,
            }{%
              tempdimb'+=\baselineskip,
            },
            tempdimb'-/.register=tempdima,
            for tree={%
              y'+/.register=tempdimb,
            },
            tempdimb'-/.register=tempdimc,
            if line numbering={%
              for name/.process={Ow1}{proof tree proof line no}{line no ##1}{%
                for tree={%
                  y'+/.register=tempdimb,
                },
              }%
            }{},
            if justifications={%
              for name/.process={Ow1}{proof tree proof line no}{just ##1}{%
                for tree={%
                  y'+/.register=tempdimb,
                },
              }%
            }{},
            tempdimc'/.register=tempdimb,
          }{},
        },
      }{},
      if={%
        > RR| {auto move}{single branches}%
      }{}{%
        where proof tree arweinydd={%
          for nodewalk={%
            save append={proof tree walk}{%
              current,
              do until={%
                > O+t_+t=! {content}{}%
              }{parent}%
            }%
          }{},
        }{},
        where level>=1{%
          if grouped={%
            if in saved nodewalk={current}{proof tree walk}{}{%
              no edge,
            },
          }{},
        }{},
      },
    },
  },
  move by/.style={%
    if={
     >{_n<}{0}{#1}%
    }{%
      proof tree cadw toing by/.option=proof tree toing by,
      proof tree arweinydd,
      for tree={%
        if={%
         >{_n<}{1}{#1}%
        }{%
          proof tree toing by+=#1-2,
          proof tree toooing'+=1,
        }{},
      },
      delay={%
        replace by={%
          [,
            if={%
             >{_n<}{1}{#1}%
            }{%
              child anchor=parent,
              parent anchor=parent,
            }{%
              child anchor=children,
              parent anchor=children,
            },
            proof tree phantom,
            edge path/.option=!last dynamic node.edge path,
            edge/.option=!last dynamic node.edge,
            append,
            proof tree before drawing tree={%
              if={>{RR|}{line numbering}{justifications}}{%
                proof tree proof line no/.process={Ow1+n}{!parent.proof tree proof line no}{##1+1},
              }{},
            },
            if={%
             >{_n<}{1}{#1}%
            }{%
              delay={%
                append={%
                  [,
                    child anchor=parent,
                    parent anchor=parent,
                    proof tree toing by=#1-2+proof_tree_cadw_toing_by,
                    proof tree phantom,
                    edge path/.option=!u.edge path,
                    edge/.option=!u.edge,
                    proof tree before drawing tree={%
                      if={>{RR|}{line numbering}{justifications}}{%
                        proof tree proof line no/.process={Ow1+n}{!n=1.proof tree proof line no}{##1-1},
                      }{},
                    },
                    append=!sibling,
                  ]%
                },
              },
            }{%
              if single branches={}{%
                delay={%
                  for children={%
                    no edge,
                  },
                },
              },
            },
           ]%
        },
      },
    }{%
      TeX/.process={Ow1}{name}{\PackageWarning{prooftrees}{Line not moved! I can only move things later in the proof. Please see the documentation for details. ##1}},
    },
  },
  proof tree cref/.style={%
    proof tree crefs+/.option=#1.name,
  },
  proof tree rhif llinell cau/.style={%
    if proof tree rhestr rhifau llinellau cau={}{}{%
      proof tree rhestr rhifau llinellau cau+={,\,},
    },
    proof tree rhestr rhifau llinellau cau+/.option=#1.proof tree proof line no,
  },
  proof tree jref/.style={%
    proof tree jrefs+/.option=#1.name,
  },
  proof tree rhif llinell/.style={%
    if proof tree rhestr rhifau llinellau={}{}{%
      proof tree rhestr rhifau llinellau+={,\,},
    },
    proof tree rhestr rhifau llinellau+/.option=#1.proof tree proof line no,
  },
  line no override/.style={%
    proof tree before drawing tree={
      for name/.process={Ow}{proof tree proof line no}{line no ##1}{
        content=\linenumberstyle{#1},
        typeset node,
      },
    },
  },
  no line no/.style={%
    proof tree before drawing tree={
      for name/.process={Ow}{proof tree proof line no}{line no ##1}{
        content=,
        typeset node,
      },
    },
  },
  prooftrees@nodewalk@node/.style={inner sep=0pt},
  nodewalk node+/.code={%
    \pgfqkeys{/forest}{prooftrees@nodewalk@node/.append style={#1}}%
  },
  +nodewalk node/.code={%
    \pgfqkeys{/forest}{prooftrees@nodewalk@node/.prepend style={#1}}%
  },
  nodewalk node'/.code={%
    \pgfqkeys{/forest}{prooftrees@nodewalk@node/.style={#1}}%
  },
  nodewalk node/.forward to=/forest/nodewalk node+,
  nodewalk to node/.style 2 args={%
    proof tree before drawing tree={%
      tikz+={%
        \node [fit to={#2},/forest/prooftrees@nodewalk@node] (#1) {};
      },
    },
  },
  proof tree dadfygio/.style={%
    proof tree before packing={%
      for tree={%
        label/.process={OOOw3}{level}{proof tree toing by}{id}{%
          [red,font=\tiny,inner sep=0pt,outer sep=0pt, anchor=south]below:##1/##2/##3%
        },
      },
    },
    proof tree before drawing tree={%
      for tree={%
        delay={%
          tikz+/.process={Ow1}{proof tree proof line no}{%
            \node [anchor=west, font=\tiny, text=blue, inner sep=0pt] at (.east) {##1};
          },
        },
      },
    },
  },
  proof tree alino/.style={%
    proof tree before drawing tree={%
      tikz+/.process={%
        RRRRw4{proof tree inner proof midpoint}{line no width}{line no dist}{just dist}
        {
          \begin{scope}[densely dashed]
            \draw [darkgray] (##1,0) coordinate (a) -- (a |- current bounding box.south);
            \draw [green] (current bounding box.west) -- ++(##2,0) coordinate (b);
            \draw [blue] (b) -- ++(##3,0) coordinate (c);
            \draw [magenta] (c) -- ++(##4,0);
          \end{scope}
        }%
      },
    },
  },
  ttableau/.style={%
  },
  tag tableau stage/.style={for root'=tag tableau,},
  tag tableau/.style={},
}
\bracketset{action character=@}
\NewDocumentEnvironment{\prooftrees@enw}{ m +b }
{%
  \global\advance\prooftrees@tableau@id by 1
  \prooftrees@ttableau@init
  \forest
    (%
      stages={%
        for root'={%
          process keylist register=default preamble,
          process keylist register=preamble,
        },
        process keylist=given options,
        process keylist=before copying content,
        process keylist=proof tree after copying content,
        process keylist=proof tree before typesetting nodes,
        process keylist=before typesetting nodes,
        process keylist=proof tree ffurf,
        process keylist=proof tree symud awto,
        typeset nodes stage,
        process keylist=proof tree before packing,
        process keylist=before packing,
        pack stage,
        process keylist=proof tree before computing xy,
        process keylist=before computing xy,
        compute xy stage,
        process keylist=before making annotations,
        process keylist=proof tree creu nodiadau,
        process keylist=before annotating,
        process keylist=proof tree nodiadau,
        process keylist=proof tree before drawing tree,
        process keylist=before drawing tree,
        process keylist=before making tags,
        process keylist=before getting tags,
        draw tree stage,
      },
    )%
    proof tree,
    #1,
    [, name=proof statement @#2]%
  \endforest
}{}
\ExplSyntaxOn
\cs_new_protected_nopar:Npn \__prooftrees_memoize:n #1
{
  \mmzset{
    auto = { #1 } { memoize },
  }
}
\cs_generate_variant:Nn \__prooftrees_memoize:n { V }
\hook_gput_code:nnn { begindocument / before } { . }
{%
  \@ifpackageloaded{memoize}{
    \__prooftrees_memoize:V \prooftrees@enw
  }{
    \newif\ifmemoizing\memoizingfalse
  }
  \cs_if_exist:NF \checkmark
  {
    \sys_if_engine_opentype:TF
    {
      \RequirePackage{unicode-math}
    }{
      \RequirePackage{amssymb}
    }
  }
  \cs_if_exist:NF \text
  {
    \sys_if_engine_opentype:TF
    {
      \RequirePackage{unicode-math}
    }{
      \RequirePackage{amstext}
    }
  }
}
\newcount\prooftrees@tableau@id
\cs_new_nopar:Npn \__tableau_ttableau_init:
{
  \tag_if_active:T{
    \PackageError{prooftrees}{Prooftrees~is~currently~incompatible~with~
      tagging.~
      The~safest~approach~is~to~compile~tableaux~standalone~and~include~
      as~images~with~detailed~alt~text.
    }{Since~you~insist,~you~can~enable~basic~tagging~support~by~loading~
      prooftrees-debug~after~prooftrees.~
      The~code~certainly~requires~LuaLaTeX~and~probably~produces~an~
      invalid~structure,~but~verapdf~validates~it~and~the~code~produces~
      alt~text~automatically.~
      I~do~not~know~how~to~make~the~structure~valid.~
      For~a~logic~package,~this~is~doubly~unfortunate.
    }
    \def\forest##1\endforest{Tableau~\the\prooftrees@tableau@id}
  }
}
\cs_new_eq:NN \prooftrees@ttableau@init \__tableau_ttableau_init:
 \cs_new_nopar:Npn \__tableau_ttableau:nnn #1#2#3
{
}
 \cs_new_eq:NN \prooftrees@ttableau \__tableau_ttableau:nnn
\ExplSyntaxOff
\endinput
%%
%% End of file `prooftrees.sty'.
